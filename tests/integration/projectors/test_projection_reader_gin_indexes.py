# SPDX-License-Identifier: MIT
# Copyright (c) 2025 OmniNode Team
"""Integration tests for GIN index usage by ProjectionReaderRegistration methods.

This test suite verifies that PostgreSQL uses GIN indexes for capability-based
queries executed through the ProjectionReaderRegistration Python methods:

1. get_by_capability_tags_all - Uses @> (contains all) operator
2. get_by_capability_tags_any - Uses && (overlaps/any) operator
3. get_by_intent_type - Uses @> operator on intent_types array
4. get_by_protocol - Uses @> operator on protocols array

These tests complement test_gin_index_usage.py by focusing on the actual
SQL patterns generated by the ProjectionReaderRegistration methods.

Related Tickets:
    - OMN-1134: Registry Projection Extensions for Capabilities
    - PR #118: Add capability fields and GIN indexes

Design Notes:
    - Tests require testcontainers with PostgreSQL
    - Tests insert sufficient data to encourage index usage over seq scan
    - EXPLAIN ANALYZE output is parsed for index scan indicators
    - Tests verify the exact SQL patterns used by ProjectionReaderRegistration
"""

from __future__ import annotations

from datetime import UTC, datetime
from typing import TYPE_CHECKING
from uuid import uuid4

import pytest
from omnibase_core.enums.enum_node_kind import EnumNodeKind

from omnibase_infra.enums import EnumRegistrationState
from omnibase_infra.models.projection import (
    ModelRegistrationProjection,
    ModelSequenceInfo,
)
from omnibase_infra.models.registration.model_node_capabilities import (
    ModelNodeCapabilities,
)

if TYPE_CHECKING:
    import asyncpg

    from omnibase_infra.projectors import ProjectorRegistration


# Test markers
pytestmark = [
    pytest.mark.asyncio,
    pytest.mark.integration,
]


# =============================================================================
# Helper Functions
# =============================================================================


def make_projection_with_capabilities(
    *,
    capability_tags: list[str] | None = None,
    intent_types: list[str] | None = None,
    protocols: list[str] | None = None,
    contract_type: str = "effect",
    offset: int = 100,
) -> ModelRegistrationProjection:
    """Create a test projection with capability fields.

    Args:
        capability_tags: Array of capability tags for discovery
        intent_types: Array of intent types this node handles
        protocols: Array of protocols this node implements
        contract_type: Node contract type (effect, compute, reducer, orchestrator)
        offset: Kafka offset for sequencing

    Returns:
        ModelRegistrationProjection configured for testing
    """
    now = datetime.now(UTC)
    return ModelRegistrationProjection(
        entity_id=uuid4(),
        domain="registration",
        current_state=EnumRegistrationState.ACTIVE,
        node_type=EnumNodeKind.EFFECT,
        node_version="1.0.0",
        capabilities=ModelNodeCapabilities(postgres=True),
        # Capability fields (OMN-1134)
        contract_type=contract_type,
        intent_types=intent_types or [],
        protocols=protocols or [],
        capability_tags=capability_tags or [],
        contract_version="1.0.0",
        # Standard fields
        last_applied_event_id=uuid4(),
        last_applied_offset=offset,
        registered_at=now,
        updated_at=now,
    )


def make_sequence(offset: int) -> ModelSequenceInfo:
    """Create sequence info for testing.

    Args:
        offset: Kafka offset (also used as sequence)

    Returns:
        ModelSequenceInfo configured for testing
    """
    return ModelSequenceInfo(
        sequence=offset,
        partition="0",
        offset=offset,
    )


async def get_query_plan(
    pool: asyncpg.Pool,
    query: str,
    *args: object,
) -> list[str]:
    """Execute EXPLAIN ANALYZE and return the query plan lines.

    Args:
        pool: asyncpg connection pool
        query: SQL query to analyze
        *args: Query parameters

    Returns:
        List of query plan lines from EXPLAIN ANALYZE output
    """
    explain_query = f"EXPLAIN ANALYZE {query}"
    async with pool.acquire() as conn:
        rows = await conn.fetch(explain_query, *args)
    return [row[0] for row in rows]


def plan_uses_gin_index(plan_lines: list[str], index_name: str | None = None) -> bool:
    """Check if the query plan uses a GIN index scan.

    Args:
        plan_lines: Lines from EXPLAIN ANALYZE output
        index_name: Optional specific index name to check for

    Returns:
        True if plan uses GIN-related index scan (Bitmap or regular), False otherwise
    """
    plan_text = "\n".join(plan_lines)

    # GIN indexes typically appear as Bitmap Index Scan or Bitmap Heap Scan
    # because GIN produces multiple row pointers that need to be sorted
    gin_indicators = [
        "Bitmap Index Scan",
        "Bitmap Heap Scan",
        "Index Scan",
    ]

    has_index_scan = any(indicator in plan_text for indicator in gin_indicators)

    if index_name and has_index_scan:
        # Also verify the specific index is used
        return index_name in plan_text

    return has_index_scan


def plan_uses_seq_scan(plan_lines: list[str]) -> bool:
    """Check if the query plan uses a sequential scan on the main table.

    Args:
        plan_lines: Lines from EXPLAIN ANALYZE output

    Returns:
        True if plan uses sequential scan on registration_projections, False otherwise
    """
    plan_text = "\n".join(plan_lines)
    return "Seq Scan on registration_projections" in plan_text


# =============================================================================
# Shared Fixtures
# =============================================================================


@pytest.fixture
async def populated_db_for_gin_tests(
    projector: ProjectorRegistration,
    pg_pool: asyncpg.Pool,
) -> asyncpg.Pool:
    """Populate database with test data for GIN index verification tests.

    Inserts 100+ projections with various capability combinations to
    provide enough data for PostgreSQL to prefer GIN index scans over
    sequential scans.

    The data distribution is designed to have:
    - Multiple rows matching each query pattern
    - Diverse capability combinations to test selectivity

    Returns:
        The pg_pool fixture for use in tests.
    """
    # Capability tag combinations for testing
    capability_tag_options = [
        ["postgres.storage"],
        ["kafka.consumer"],
        ["http.client"],
        ["redis.cache"],
        ["postgres.storage", "kafka.consumer"],
        ["http.client", "redis.cache"],
        ["postgres.storage", "kafka.consumer", "http.client"],
        ["postgres.storage", "redis.cache"],
        [],
    ]

    # Intent type combinations for testing
    intent_type_options = [
        ["postgres.upsert"],
        ["postgres.query"],
        ["kafka.publish"],
        ["http.request"],
        ["postgres.upsert", "postgres.query"],
        ["kafka.publish", "kafka.consume"],
        ["postgres.upsert", "kafka.publish"],
        [],
    ]

    # Protocol combinations for testing
    protocol_options = [
        ["ProtocolDatabaseAdapter"],
        ["ProtocolEventPublisher"],
        ["ProtocolHttpClient"],
        ["ProtocolCacheAdapter"],
        ["ProtocolDatabaseAdapter", "ProtocolEventPublisher"],
        ["ProtocolHttpClient", "ProtocolCacheAdapter"],
        [],
    ]

    # Insert 100 projections with diverse combinations
    for i in range(100):
        projection = make_projection_with_capabilities(
            capability_tags=capability_tag_options[i % len(capability_tag_options)],
            intent_types=intent_type_options[i % len(intent_type_options)],
            protocols=protocol_options[i % len(protocol_options)],
            offset=5000 + i,
        )
        await projector.persist(
            projection=projection,
            entity_id=projection.entity_id,
            domain=projection.domain,
            sequence_info=make_sequence(5000 + i),
        )

    # Run ANALYZE to update table statistics for optimal query planning
    async with pg_pool.acquire() as conn:
        await conn.execute("ANALYZE registration_projections")

    return pg_pool


# =============================================================================
# GIN Index Usage Tests for ProjectionReaderRegistration Methods
# =============================================================================


class TestProjectionReaderGinIndexUsage:
    """Integration tests verifying GIN index usage for ProjectionReaderRegistration.

    These tests verify that the SQL patterns used by ProjectionReaderRegistration
    methods result in GIN index usage by PostgreSQL query planner.

    Each test:
    1. Uses EXPLAIN ANALYZE on the exact SQL pattern the method generates
    2. Verifies index scan appears in the query plan
    3. Confirms no sequential scan on the registration_projections table

    Note: PostgreSQL may choose sequential scan for very small tables. These
    tests insert sufficient data (100+ rows) and run ANALYZE to encourage
    index usage. The assertions allow for either index usage OR no sequential
    scan to handle query planner variations.
    """

    async def test_get_by_capability_tags_all_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_capability_tags_all query pattern uses GIN index.

        Tests the @> (contains all) operator on capability_tags array.
        This is the exact SQL pattern used by:
            ProjectionReaderRegistration.get_by_capability_tags_all()

        The GIN index idx_registration_capability_tags should be used
        for efficient array containment checks.
        """
        pool = populated_db_for_gin_tests

        # This is the exact SQL pattern from get_by_capability_tags_all
        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND capability_tags @> $2::text[]
            ORDER BY updated_at DESC
            LIMIT $3
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["postgres.storage", "kafka.consumer"],  # Multi-tag query
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_capability_tags")
        uses_seq = plan_uses_seq_scan(plan_lines)

        # Assert GIN index is used OR no sequential scan
        # (PostgreSQL planner may choose different strategies based on statistics)
        assert uses_gin or not uses_seq, (
            "Expected GIN index usage for get_by_capability_tags_all (@> operator). "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

        # Verify query returns results (sanity check)
        async with pool.acquire() as conn:
            rows = await conn.fetch(
                query,
                "registration",
                ["postgres.storage", "kafka.consumer"],
                100,
            )
        assert len(rows) > 0, (
            "Expected at least one row with both postgres.storage AND kafka.consumer"
        )

    async def test_get_by_capability_tags_any_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_capability_tags_any query pattern uses GIN index.

        Tests the && (overlaps/any) operator on capability_tags array.
        This is the exact SQL pattern used by:
            ProjectionReaderRegistration.get_by_capability_tags_any()

        The GIN index idx_registration_capability_tags should be used
        for efficient array overlap checks.

        IMPORTANT: This test specifically verifies the && operator is indexed,
        which is different from the @> operator tested in other tests.
        """
        pool = populated_db_for_gin_tests

        # This is the exact SQL pattern from get_by_capability_tags_any
        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND capability_tags && $2::text[]
            ORDER BY updated_at DESC
            LIMIT $3
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["postgres.storage", "redis.cache"],  # Any of these tags
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_capability_tags")
        uses_seq = plan_uses_seq_scan(plan_lines)

        # Assert GIN index is used OR no sequential scan
        assert uses_gin or not uses_seq, (
            "Expected GIN index usage for get_by_capability_tags_any (&& operator). "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

        # Verify query returns results (sanity check)
        async with pool.acquire() as conn:
            rows = await conn.fetch(
                query,
                "registration",
                ["postgres.storage", "redis.cache"],
                100,
            )
        assert len(rows) > 0, (
            "Expected at least one row with postgres.storage OR redis.cache"
        )

    async def test_get_by_intent_type_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_intent_type query pattern uses GIN index.

        Tests the @> operator on intent_types array.
        This is the exact SQL pattern used by:
            ProjectionReaderRegistration.get_by_intent_type()

        The GIN index idx_registration_intent_types should be used
        for efficient intent type lookups.
        """
        pool = populated_db_for_gin_tests

        # This is the exact SQL pattern from get_by_intent_type
        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND intent_types @> $2::text[]
            ORDER BY updated_at DESC
            LIMIT $3
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["postgres.upsert"],
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_intent_types")
        uses_seq = plan_uses_seq_scan(plan_lines)

        # Assert GIN index is used OR no sequential scan
        assert uses_gin or not uses_seq, (
            "Expected GIN index usage for get_by_intent_type (@> operator). "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

        # Verify query returns results (sanity check)
        async with pool.acquire() as conn:
            rows = await conn.fetch(
                query,
                "registration",
                ["postgres.upsert"],
                100,
            )
        assert len(rows) > 0, "Expected at least one row with postgres.upsert intent"

    async def test_get_by_protocol_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_protocol query pattern uses GIN index.

        Tests the @> operator on protocols array.
        This is the exact SQL pattern used by:
            ProjectionReaderRegistration.get_by_protocol()

        The GIN index idx_registration_protocols should be used
        for efficient protocol lookups.
        """
        pool = populated_db_for_gin_tests

        # This is the exact SQL pattern from get_by_protocol
        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND protocols @> $2::text[]
            ORDER BY updated_at DESC
            LIMIT $3
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["ProtocolDatabaseAdapter"],
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_protocols")
        uses_seq = plan_uses_seq_scan(plan_lines)

        # Assert GIN index is used OR no sequential scan
        assert uses_gin or not uses_seq, (
            "Expected GIN index usage for get_by_protocol (@> operator). "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

        # Verify query returns results (sanity check)
        async with pool.acquire() as conn:
            rows = await conn.fetch(
                query,
                "registration",
                ["ProtocolDatabaseAdapter"],
                100,
            )
        assert len(rows) > 0, (
            "Expected at least one row with ProtocolDatabaseAdapter protocol"
        )


# =============================================================================
# GIN Index Usage with State Filter Tests
# =============================================================================


class TestProjectionReaderGinIndexWithStateFilter:
    """Tests verifying GIN index usage when combined with state filter.

    These tests verify that capability queries combined with state filtering
    still benefit from GIN indexes. The query planner should use the GIN
    index for array operations even when combined with equality conditions.
    """

    async def test_capability_tags_all_with_state_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_capability_tags_all with state filter uses GIN index.

        Tests the combined query pattern:
            capability_tags @> $2::text[] AND current_state = $3
        """
        pool = populated_db_for_gin_tests

        # SQL pattern from get_by_capability_tags_all with state filter
        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND capability_tags @> $2::text[]
              AND current_state = $3
            ORDER BY updated_at DESC
            LIMIT $4
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["postgres.storage"],
            "active",
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_capability_tags")
        uses_seq = plan_uses_seq_scan(plan_lines)

        # With combined conditions, planner may choose index on capability_tags
        # or the composite index on (contract_type, current_state)
        assert uses_gin or not uses_seq, (
            "Expected index usage for combined capability + state query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

    async def test_capability_tags_any_with_state_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_capability_tags_any with state filter uses GIN index.

        Tests the combined query pattern:
            capability_tags && $2::text[] AND current_state = $3
        """
        pool = populated_db_for_gin_tests

        # SQL pattern from get_by_capability_tags_any with state filter
        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND capability_tags && $2::text[]
              AND current_state = $3
            ORDER BY updated_at DESC
            LIMIT $4
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["postgres.storage", "kafka.consumer"],
            "active",
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_capability_tags")
        uses_seq = plan_uses_seq_scan(plan_lines)

        assert uses_gin or not uses_seq, (
            "Expected index usage for combined capability (&&) + state query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

    async def test_intent_type_with_state_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_intent_type with state filter uses GIN index."""
        pool = populated_db_for_gin_tests

        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND intent_types @> $2::text[]
              AND current_state = $3
            ORDER BY updated_at DESC
            LIMIT $4
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["kafka.publish"],
            "active",
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_intent_types")
        uses_seq = plan_uses_seq_scan(plan_lines)

        assert uses_gin or not uses_seq, (
            "Expected index usage for intent_type + state query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

    async def test_protocol_with_state_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify get_by_protocol with state filter uses GIN index."""
        pool = populated_db_for_gin_tests

        query = """
            SELECT * FROM registration_projections
            WHERE domain = $1
              AND protocols @> $2::text[]
              AND current_state = $3
            ORDER BY updated_at DESC
            LIMIT $4
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            "registration",
            ["ProtocolEventPublisher"],
            "active",
            100,
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_protocols")
        uses_seq = plan_uses_seq_scan(plan_lines)

        assert uses_gin or not uses_seq, (
            "Expected index usage for protocol + state query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )


# =============================================================================
# Edge Case Tests for GIN Index Behavior
# =============================================================================


class TestGinIndexEdgeCases:
    """Edge case tests for GIN index behavior.

    These tests verify GIN index behavior in edge cases that might
    affect query planning or index usage patterns.
    """

    async def test_single_tag_query_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify single-element array queries use GIN index.

        Even with a single tag, the @> operator should use the GIN index.
        """
        pool = populated_db_for_gin_tests

        query = """
            SELECT * FROM registration_projections
            WHERE capability_tags @> $1::text[]
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            ["postgres.storage"],
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_capability_tags")
        uses_seq = plan_uses_seq_scan(plan_lines)

        assert uses_gin or not uses_seq, (
            "Expected GIN index usage for single-tag query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

    async def test_empty_result_query_still_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify queries returning no results still use GIN index.

        The index should be used for query execution even if the
        result set is empty. This verifies the planner doesn't
        fall back to seq scan for non-existent values.
        """
        pool = populated_db_for_gin_tests

        query = """
            SELECT * FROM registration_projections
            WHERE capability_tags @> $1::text[]
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            ["nonexistent.capability.tag.12345"],
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_capability_tags")
        uses_seq = plan_uses_seq_scan(plan_lines)

        assert uses_gin or not uses_seq, (
            "Expected GIN index usage even for non-matching query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

    async def test_multiple_tags_any_operator_uses_gin_index(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify multi-element && (any) query uses GIN index.

        The && operator should efficiently use the GIN index to find
        rows with ANY of the specified tags.
        """
        pool = populated_db_for_gin_tests

        query = """
            SELECT * FROM registration_projections
            WHERE capability_tags && $1::text[]
        """

        # Query with many tags - should still use index
        plan_lines = await get_query_plan(
            pool,
            query,
            ["postgres.storage", "kafka.consumer", "http.client", "redis.cache"],
        )

        uses_gin = plan_uses_gin_index(plan_lines, "idx_registration_capability_tags")
        uses_seq = plan_uses_seq_scan(plan_lines)

        assert uses_gin or not uses_seq, (
            "Expected GIN index usage for multi-tag && query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )

    async def test_combined_gin_indexes_query(
        self,
        populated_db_for_gin_tests: asyncpg.Pool,
    ) -> None:
        """Verify query combining multiple GIN-indexed columns uses indexes.

        When querying both capability_tags AND intent_types, the planner
        should use at least one of the GIN indexes, typically choosing
        the more selective one.
        """
        pool = populated_db_for_gin_tests

        query = """
            SELECT * FROM registration_projections
            WHERE capability_tags @> $1::text[]
              AND intent_types @> $2::text[]
        """

        plan_lines = await get_query_plan(
            pool,
            query,
            ["postgres.storage"],
            ["postgres.upsert"],
        )

        # Should use at least one GIN index
        uses_capability_gin = plan_uses_gin_index(
            plan_lines, "idx_registration_capability_tags"
        )
        uses_intent_gin = plan_uses_gin_index(
            plan_lines, "idx_registration_intent_types"
        )
        uses_any_gin = uses_capability_gin or uses_intent_gin
        uses_seq = plan_uses_seq_scan(plan_lines)

        assert uses_any_gin or not uses_seq, (
            "Expected at least one GIN index for combined capability+intent query. "
            f"Query plan:\n{chr(10).join(plan_lines)}"
        )
