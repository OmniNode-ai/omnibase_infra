# SPDX-License-Identifier: MIT
# Copyright (c) 2025 OmniNode Team
"""Orchestrator purity tests for OMN-952.

These tests verify that the Registration Orchestrator emits events only,
adhering to the ONEX orchestrator design principle that orchestrators
should coordinate work and emit status events, not commands or intents.

Design Rationale:
-----------------
In ONEX architecture, orchestrators serve as workflow coordinators that:
1. Receive events (introspection, heartbeats, ticks)
2. Coordinate reducer and effect nodes
3. Emit events to signal workflow state changes

Orchestrators should NOT:
- Emit commands (which direct other nodes to take action)
- Emit intents (which represent desired state changes)

This separation ensures clean event-driven architecture where:
- Commands are issued by external actors or gateways
- Intents are generated by reducers
- Events are facts about what happened (emitted by all node types)

Test Categories:
---------------
1. Contract-level tests: Verify published_events in contract.yaml
2. Model-level tests: Verify output model structure supports events only
3. Naming convention tests: Verify ONEX event naming standards

Running Tests:
    # Run all purity tests:
    pytest tests/unit/nodes/test_orchestrator_purity.py -v

    # Run specific test:
    pytest tests/unit/nodes/test_orchestrator_purity.py::TestOrchestratorEventPurity -v
"""

from __future__ import annotations

import re

# =============================================================================
# Fixtures
# =============================================================================
# Note: contract_path and contract_data fixtures are provided by conftest.py
# with module-level scope for performance (parse YAML once per module).

# =============================================================================
# ONEX Topic Pattern Constants
# =============================================================================

# ONEX topic patterns for message categorization
# Pattern: {env}.{namespace}.onex.<category>.<event-name>.v<version>
EVENT_TOPIC_PATTERN = r"\.evt\."  # Events: facts about what happened
COMMAND_TOPIC_PATTERN = r"\.cmd\."  # Commands: directives to take action
INTENT_TOPIC_PATTERN = r"\.int\."  # Intents: desired state changes

# ONEX event naming convention regex
# Full pattern: {env}.{namespace}.onex.evt.<producer>.<kebab-case-name>.v<version>
ONEX_EVENT_TOPIC_REGEX = re.compile(
    r"^\{env\}\.\{namespace\}\.onex\.evt\.[a-z][a-z0-9-]*\.[a-z][a-z0-9-]*\.v[0-9]+$"
)


# =============================================================================
# TestOrchestratorEventPurity
# =============================================================================


class TestOrchestratorEventPurity:
    """Tests verifying orchestrator emits events only (no commands, no intents).

    These tests implement the acceptance criterion from OMN-952:
    "Emits events only (no commands, no intents)"

    ONEX Architecture Context:
    - Orchestrators coordinate workflows by calling reducer and effect nodes
    - Orchestrators emit events to signal workflow state (initiated, completed, failed)
    - Commands and intents are the domain of other node types (gateways, reducers)
    """

    def test_published_events_are_all_events(self, contract_data: dict) -> None:
        """Verify all topics in published_events contain '.evt.' pattern.

        This test ensures that every topic defined in the contract's published_events
        section follows the ONEX event topic naming pattern. Events use '.evt.' in
        their topic pattern, distinguishing them from commands ('.cmd.') and
        intents ('.int.').

        Acceptance Criterion:
            All published_events topics must contain the '.evt.' pattern,
            indicating they are events (facts about what happened) rather than
            commands (directives) or intents (desired state changes).

        ONEX Event Pattern:
            {env}.{namespace}.onex.evt.<event-name>.v<version>
        """
        published_events = contract_data.get("published_events", [])

        assert len(published_events) > 0, (
            "Contract must define at least one published event for orchestrator"
        )

        for event in published_events:
            topic = event.get("topic", "")
            event_type = event.get("event_type", "unknown")

            # Verify topic contains .evt. pattern (event marker)
            assert re.search(EVENT_TOPIC_PATTERN, topic), (
                f"Published topic for '{event_type}' must contain '.evt.' pattern "
                f"(event marker). Got topic: '{topic}'. "
                f"Orchestrators should only emit events, not commands or intents."
            )

    def test_no_command_topics_in_contract(self, contract_data: dict) -> None:
        """Verify no '.cmd.' patterns exist in published_events.

        This test explicitly validates that no command topics are present in the
        orchestrator's published_events. Commands are directives that tell other
        nodes to take action, which violates the orchestrator purity principle.

        Acceptance Criterion:
            No published_events topics may contain the '.cmd.' pattern.
            Orchestrators coordinate work but do not issue commands.

        Design Rationale:
            Commands in ONEX are issued by:
            - External gateways (API calls from external systems)
            - User-facing services (responding to user actions)

            Orchestrators should NOT issue commands because:
            - They coordinate workflow, not direct action
            - Commands create tight coupling between orchestrator and receivers
            - Event-driven coordination is more resilient and testable
        """
        published_events = contract_data.get("published_events", [])

        for event in published_events:
            topic = event.get("topic", "")
            event_type = event.get("event_type", "unknown")

            # Verify topic does NOT contain .cmd. pattern (command marker)
            assert not re.search(COMMAND_TOPIC_PATTERN, topic), (
                f"Published topic for '{event_type}' contains '.cmd.' pattern "
                f"(command marker). Topic: '{topic}'. "
                f"Orchestrators must NOT emit commands - they coordinate via events."
            )

        # Also check consumed_events for completeness (consumed can have any type)
        # But published should NEVER have commands
        consumed_events = contract_data.get("consumed_events", [])
        published_topics = {e.get("topic") for e in published_events}
        {e.get("topic") for e in consumed_events}

        # Published and consumed should not share command topics
        for topic in published_topics:
            assert not re.search(COMMAND_TOPIC_PATTERN, topic), (
                f"Published topic '{topic}' is a command topic - not allowed"
            )

    def test_no_intent_emission_in_output_model(self) -> None:
        """Verify ModelOrchestratorOutput only contains event-related fields.

        This test examines the orchestrator's output model to ensure it does not
        contain fields that would indicate intent emission. Intent emission would
        violate the orchestrator purity principle.

        Acceptance Criterion:
            ModelOrchestratorOutput must not contain fields named 'emitted_intents',
            'published_intents', 'output_intents', or similar patterns that would
            indicate the orchestrator is emitting intents.

        Design Rationale:
            Intents in ONEX represent desired state changes and are:
            - Generated by reducer nodes (from events)
            - Executed by effect nodes (to external systems)

            Orchestrators should NOT emit intents because:
            - They coordinate the reducer -> effect flow
            - Intent generation is the reducer's responsibility
            - Mixing concerns reduces testability and clarity

        Fields that ARE acceptable:
            - intent_results: Results OF intent execution (not emission)
            - correlation_id, status, timing: Standard output metadata
        """
        from omnibase_infra.nodes.node_registration_orchestrator.models import (
            ModelOrchestratorOutput,
        )

        # Get all field names from the output model
        field_names = set(ModelOrchestratorOutput.model_fields.keys())

        # Fields that would indicate intent emission (NOT allowed)
        forbidden_intent_fields = {
            "emitted_intents",
            "published_intents",
            "output_intents",
            "intents_to_emit",
            "pending_intents",
            "generated_intents",
        }

        # Check for forbidden fields
        found_forbidden = forbidden_intent_fields & field_names
        assert not found_forbidden, (
            f"ModelOrchestratorOutput contains intent emission fields: {found_forbidden}. "
            f"Orchestrators must not emit intents - they coordinate intent execution."
        )

        # Verify intent_results is about RESULTS, not emission
        if "intent_results" in field_names:
            # This is acceptable - it's the results of intent execution
            # by effect nodes, not intent emission by the orchestrator
            field_info = ModelOrchestratorOutput.model_fields["intent_results"]
            description = field_info.description or ""

            # Verify the field description indicates results, not emission
            assert (
                "result" in description.lower() or "execution" in description.lower()
            ), (
                f"Field 'intent_results' should describe execution results, "
                f"got description: '{description}'"
            )

    def test_orchestrator_output_type_is_event_envelope(
        self, contract_data: dict
    ) -> None:
        """Verify output is wrapped in event envelope, not command/intent envelope.

        This test validates that the orchestrator's output model is designed to
        produce event data that can be wrapped in an event envelope. The output
        model name should reflect event semantics, not command or intent semantics.

        Acceptance Criterion:
            The output_model specified in contract.yaml should be named to reflect
            event/result semantics (e.g., 'Output', 'Result') rather than
            command/intent semantics (e.g., 'Command', 'Intent', 'Request').

        Design Rationale:
            ONEX uses typed envelopes to wrap messages:
            - EventEnvelope: Wraps facts about what happened
            - CommandEnvelope: Wraps directives to take action
            - IntentEnvelope: Wraps desired state changes

            Orchestrator output should be event-compatible because it reports
            workflow status and results, which are facts (events).
        """
        output_model = contract_data.get("output_model", {})
        model_name = output_model.get("name", "")

        # Valid output model naming patterns (event/result semantics)
        valid_patterns = [
            "Output",  # Standard output model naming
            "Result",  # Result-oriented naming
            "Event",  # Event-oriented naming
            "Response",  # Response-oriented naming
        ]

        # Invalid naming patterns (command/intent semantics)
        invalid_patterns = [
            "Command",  # Command emission
            "Intent",  # Intent emission
            "Request",  # Request emission (implies command)
            "Directive",  # Directive emission
            "Instruction",  # Instruction emission
        ]

        # Verify model name follows event/result semantics
        has_valid_pattern = any(pattern in model_name for pattern in valid_patterns)
        has_invalid_pattern = any(pattern in model_name for pattern in invalid_patterns)

        assert has_valid_pattern, (
            f"Output model name '{model_name}' should contain one of {valid_patterns} "
            f"to indicate event/result semantics. Orchestrators emit events, not commands."
        )

        assert not has_invalid_pattern, (
            f"Output model name '{model_name}' contains invalid pattern from {invalid_patterns}. "
            f"Orchestrators must not emit commands or intents."
        )

        # Verify the module path is consistent with node structure
        module_path = output_model.get("module", "")
        assert "node_registration_orchestrator" in module_path, (
            f"Output model module '{module_path}' should be within orchestrator node package"
        )

    def test_contract_published_events_match_onex_event_naming(
        self, contract_data: dict
    ) -> None:
        """Verify event types follow ONEX event naming conventions.

        This test validates that all published event types follow the ONEX
        naming conventions for events:
        1. Topic pattern: {env}.{namespace}.onex.evt.<kebab-case-name>.v<version>
        2. Event type naming: PascalCase, descriptive of the event

        Acceptance Criterion:
            All published_events must have:
            - Topics matching ONEX event topic pattern
            - Event types in PascalCase format
            - Semantic names indicating facts (past tense or state)

        ONEX Event Naming Rules:
            Topics: kebab-case, e.g., 'node-registration-result'
            Event Types: PascalCase, e.g., 'NodeRegistrationResultEvent'
        """
        published_events = contract_data.get("published_events", [])

        assert len(published_events) > 0, "Contract must define published events"

        for event in published_events:
            topic = event.get("topic", "")
            event_type = event.get("event_type", "")

            # Test 1: Topic matches ONEX event naming pattern
            assert ONEX_EVENT_TOPIC_REGEX.match(topic), (
                f"Topic '{topic}' does not match ONEX event naming convention. "
                f"Expected pattern: {{env}}.{{namespace}}.onex.evt.<kebab-case-name>.v<version>"
            )

            # Test 2: Event type is non-empty and properly formatted
            assert event_type, f"Event type missing for topic '{topic}'"

            # Test 3: Event type is PascalCase (starts with uppercase, no underscores)
            assert event_type[0].isupper(), (
                f"Event type '{event_type}' must start with uppercase (PascalCase)"
            )
            assert "_" not in event_type, (
                f"Event type '{event_type}' must be PascalCase, not snake_case"
            )

            # Test 4: Event type contains semantic indicators
            # Events should indicate facts/state, not commands
            event_indicators = [
                "Event",
                "Result",
                "Initiated",
                "Completed",
                "Failed",
                "Accepted",
                "Rejected",
                "Received",
                "Expired",
                "Active",
                "TimedOut",
            ]
            command_indicators = [
                "Command",
                "Request",
                "Execute",
                "Create",
                "Update",
                "Delete",
                "Send",
                "Dispatch",
            ]

            # Verify it looks like an event, not a command
            has_event_indicator = any(ind in event_type for ind in event_indicators)
            has_command_indicator = any(ind in event_type for ind in command_indicators)

            assert has_event_indicator or not has_command_indicator, (
                f"Event type '{event_type}' appears to be a command, not an event. "
                f"Event types should indicate facts (past tense) or state changes."
            )


# =============================================================================
# TestOrchestratorPurityEdgeCases
# =============================================================================


class TestOrchestratorPurityEdgeCases:
    """Edge case tests for orchestrator purity verification.

    These tests cover edge cases and boundary conditions for the purity checks,
    ensuring robust validation of the orchestrator's event-only emission.
    """

    def test_consumed_events_can_include_commands(self, contract_data: dict) -> None:
        """Verify consumed_events can include any message type (not just events).

        This test confirms that while the orchestrator can CONSUME various message
        types (events, commands, ticks), it should only PUBLISH events.

        Design Note:
            Orchestrators may consume:
            - Events: Facts from other nodes (introspection events)
            - Commands: External requests (optional, via gateways)
            - Internal messages: Runtime ticks for timeout evaluation

            But orchestrators should only publish events.
        """
        consumed_events = contract_data.get("consumed_events", [])
        published_events = contract_data.get("published_events", [])

        # Consumed can have any type - this is NOT restricted
        # Published must be events only - this IS restricted

        # Just verify both are present
        assert len(consumed_events) > 0, "Orchestrator must consume events"
        assert len(published_events) > 0, "Orchestrator must publish events"

        # All published must be events (already tested above, but re-verify)
        for event in published_events:
            topic = event.get("topic", "")
            assert ".evt." in topic, f"Published topic must be event: {topic}"

    def test_internal_events_follow_convention(self, contract_data: dict) -> None:
        """Verify internal events (like RuntimeTick) are properly marked.

        Internal events used for orchestrator coordination (like RuntimeTick)
        should be properly marked as internal in the contract.
        """
        consumed_events = contract_data.get("consumed_events", [])

        for event in consumed_events:
            topic = event.get("topic", "")
            event_type = event.get("event_type", "")
            is_internal = event.get("internal", False)

            # RuntimeTick and similar internal events should be marked
            if "runtime-tick" in topic.lower() or "internal" in topic.lower():
                assert is_internal, (
                    f"Event '{event_type}' on topic '{topic}' appears internal "
                    f"but is not marked as internal=true"
                )

    def test_published_event_count_matches_expected(self, contract_data: dict) -> None:
        """Verify expected number of published events for registration orchestrator.

        The registration orchestrator should publish a specific set of events
        corresponding to the FSM state transitions:
        - NodeRegistrationResultEvent (final result)
        - NodeRegistrationInitiated (workflow started)
        - NodeRegistrationAccepted (registration accepted)
        - NodeRegistrationRejected (registration rejected)
        - NodeRegistrationAckTimedOut (ACK timeout)
        - NodeRegistrationAckReceived (ACK received)
        - NodeBecameActive (node activated)
        - NodeLivenessExpired (liveness expired)
        """
        published_events = contract_data.get("published_events", [])
        event_types = {e.get("event_type") for e in published_events}

        # Expected FSM-related events
        expected_events = {
            "NodeRegistrationResultEvent",
            "NodeRegistrationInitiated",
            "NodeRegistrationAccepted",
            "NodeRegistrationRejected",
            "NodeRegistrationAckTimedOut",
            "NodeRegistrationAckReceived",
            "NodeBecameActive",
            "NodeLivenessExpired",
        }

        # Verify all expected events are present
        missing_events = expected_events - event_types
        assert not missing_events, (
            f"Missing expected published events: {missing_events}"
        )

        # Verify count matches (exactly these events, no extras)
        assert len(published_events) == len(expected_events), (
            f"Expected {len(expected_events)} published events, "
            f"got {len(published_events)}. "
            f"Extra events: {event_types - expected_events}"
        )


# =============================================================================
# Module Exports
# =============================================================================

__all__ = [
    "TestOrchestratorEventPurity",
    "TestOrchestratorPurityEdgeCases",
]
