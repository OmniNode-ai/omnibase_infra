# Node Service Mixin Subcontract - Service Lifecycle Management Pattern
# This subcontract defines service lifecycle patterns for MixinNodeService integration

contract_type: "node_service_mixin_subcontract"
contract_version:
  major: 1
  minor: 0
  patch: 0

metadata:
  name: "NodeServiceMixinSubcontract"
  description: "Service lifecycle management pattern for MixinNodeService integration with ONEX nodes"
  author: "ONEX Framework Team"
  created: "2025-01-15"
  purpose: "Define service lifecycle patterns for node service management via MixinNodeService"

business_logic:
  pattern: "node_service_lifecycle"
  ai_agent:
    capabilities: ["service_startup", "service_shutdown", "service_monitoring", "event_bus_integration"]
    coordination_patterns: ["service_registry", "event_subscriber", "lifecycle_manager"]
    performance_targets:
      service_startup_time: "<500ms"
      service_shutdown_time: "<200ms"
      heartbeat_frequency: "30s"

# Service Lifecycle Management
service_lifecycle:
  name: "NodeServiceLifecycle"
  description: "Standardized service lifecycle management for ONEX infrastructure nodes"

  # Service initialization patterns
  initialization_patterns:
    startup_sequence:
      - step: "container_injection"
        description: "Inject ONEXContainer with dependencies"
        required: true
        timeout_ms: 1000

      - step: "event_bus_connection"
        description: "Connect to ONEX event bus for service coordination"
        required: true
        timeout_ms: 2000

      - step: "metadata_loader_initialization"
        description: "Initialize schema and metadata loading capabilities"
        required: true
        timeout_ms: 500

      - step: "service_registration"
        description: "Register service with ONEX service registry"
        required: true
        timeout_ms: 1000

      - step: "health_check_initialization"
        description: "Initialize service health monitoring"
        required: false
        timeout_ms: 500

    dependency_injection:
      - service: "ProtocolEventBus"
        purpose: "Event bus integration for service coordination"
        required: true
        fallback: "emit_initialization_error"

      - service: "ProtocolSchemaLoader"
        purpose: "Schema and metadata loading for service operations"
        required: true
        fallback: "use_default_schema_loader"

      - service: "ProtocolServiceRegistry"
        purpose: "Service registration and discovery"
        required: false
        fallback: "skip_service_registration"

  # Service shutdown patterns
  shutdown_patterns:
    graceful_shutdown:
      - step: "stop_accepting_requests"
        description: "Stop accepting new service requests"
        timeout_ms: 100

      - step: "complete_active_operations"
        description: "Allow active operations to complete"
        timeout_ms: 5000

      - step: "disconnect_event_bus"
        description: "Gracefully disconnect from event bus"
        timeout_ms: 1000

      - step: "cleanup_resources"
        description: "Clean up service-specific resources"
        timeout_ms: 2000

      - step: "service_deregistration"
        description: "Deregister from service registry"
        timeout_ms: 500

    forced_shutdown:
      - step: "immediate_resource_cleanup"
        description: "Immediately clean up critical resources"
        timeout_ms: 500

      - step: "emergency_deregistration"
        description: "Emergency service deregistration"
        timeout_ms: 100

# Event Bus Integration
event_bus_integration:
  service_coordination:
    heartbeat_events:
      event_type: "service_heartbeat"
      frequency_seconds: 30
      payload_fields: ["service_id", "status", "timestamp", "health_status"]

    lifecycle_events:
      service_started:
        event_type: "service_lifecycle_started"
        payload: ["service_id", "node_type", "domain", "capabilities"]

      service_stopping:
        event_type: "service_lifecycle_stopping"
        payload: ["service_id", "shutdown_reason", "estimated_shutdown_time"]

      service_stopped:
        event_type: "service_lifecycle_stopped"
        payload: ["service_id", "final_status", "shutdown_duration_ms"]

  event_handling:
    subscriptions:
      - event_pattern: "service_discovery_request"
        handler: "handle_service_discovery"
        response_required: true

      - event_pattern: "service_health_inquiry"
        handler: "handle_health_inquiry"
        response_required: true

      - event_pattern: "service_shutdown_request"
        handler: "handle_shutdown_request"
        response_required: false

# Service Registry Integration
service_registry:
  registration_strategy:
    registration_data:
      - field: "service_id"
        source: "node_id_from_contract"
        required: true

      - field: "service_type"
        source: "node_type_property"
        required: true

      - field: "domain"
        source: "domain_property"
        required: true

      - field: "capabilities"
        source: "service_capabilities_method"
        required: false

      - field: "health_endpoint"
        source: "health_check_url"
        required: false

    registration_timing:
      register_on_startup: true
      deregister_on_shutdown: true
      reregister_on_failure: true

  discovery_patterns:
    service_advertising:
      advertise_capabilities: true
      advertise_health_status: true
      advertise_load_metrics: false

# Health Monitoring Integration
health_monitoring:
  health_check_integration:
    delegate_to_mixin: true
    mixin_class: "MixinHealthCheck"
    health_check_frequency: 30000  # milliseconds

  monitoring_metrics:
    service_metrics:
      - "service.uptime_seconds"
      - "service.request_count"
      - "service.error_rate"
      - "service.response_time_ms"

    integration_metrics:
      - "service.event_bus_connectivity"
      - "service.registry_connectivity"
      - "service.dependency_health"

# Error Handling and Recovery
error_handling:
  initialization_errors:
    container_injection_failed:
      action: "fail_startup_with_error"
      retry: false

    event_bus_connection_failed:
      action: "retry_with_backoff"
      max_retries: 3
      backoff_strategy: "exponential"

    service_registration_failed:
      action: "log_warning_continue_startup"
      retry: true
      max_retries: 2

  runtime_errors:
    event_bus_disconnection:
      action: "attempt_reconnection"
      max_attempts: 5
      escalate_after: "emit_service_degraded_event"

    dependency_unavailable:
      action: "mark_service_degraded"
      fallback_behavior: "limited_functionality_mode"

# Performance Optimization
performance_optimization:
  service_startup:
    parallel_initialization: true
    lazy_dependency_loading: true
    connection_pooling: true

  runtime_efficiency:
    event_batching: true
    connection_reuse: true
    metric_aggregation: true

# Code Generation Targets
generation_targets:
  mixin_integration:
    service_lifecycle_hooks: true
    event_bus_handlers: true
    registry_integration: true
    health_monitoring_integration: true

  dependency_injection:
    container_integration: true
    service_resolution: true
    protocol_enforcement: true

# Integration with Main Contract
integration:
  main_contract_field: "service_lifecycle_configuration"
  mapping_strategy: "mixin_embedding"
  backward_compatibility: true