-- Migration: 005_create_decision_store.sql
-- Purpose: Create decision_store and decision_conflicts tables for the
--          ONEX architectural decision management system.
-- Author: ONEX Infrastructure Team
-- Date: 2026-02-25
-- Ticket: OMN-2764
--
-- Design Decisions:
--
--   1. decision_store is the canonical record of architectural decisions.
--      Each decision has a stable UUID primary key (decision_id) supplied
--      by the application layer — not generated by the DB — so that IDs can
--      be assigned deterministically before the row is written.
--
--   2. decision_conflicts tracks pairs of decisions with potential conflicts.
--      The (decision_min_id, decision_max_id) pair is normalised so that
--      min < max, enforced by chk_conflict_pair_order.  This prevents
--      duplicate pairs stored in reverse order.
--
--   3. No materialized view.  Direct indexed queries are sufficient for MVP.
--      The partial index on (scope_domain, scope_layer WHERE status='ACTIVE')
--      keeps the hot-path query fast without maintaining a separate view.
--
--   4. All idempotent via IF NOT EXISTS so re-running the migration is safe.
--
--   5. GIN index on scope_services supports JSONB containment / overlap
--      queries (e.g. "decisions affecting service X").

-- =============================================================================
-- TABLE: decision_store
-- =============================================================================

CREATE TABLE IF NOT EXISTS decision_store (
    decision_id     UUID PRIMARY KEY,
    correlation_id  UUID NOT NULL,
    title           TEXT NOT NULL,
    decision_type   TEXT NOT NULL,
    status          TEXT NOT NULL DEFAULT 'ACTIVE'
        CHECK (status IN ('PROPOSED', 'ACTIVE', 'SUPERSEDED', 'DEPRECATED')),
    scope_domain    TEXT NOT NULL,
    scope_services  JSONB NOT NULL DEFAULT '[]',
    scope_layer     TEXT NOT NULL
        CHECK (scope_layer IN ('architecture', 'design', 'planning', 'implementation')),
    rationale       TEXT NOT NULL,
    alternatives    JSONB NOT NULL DEFAULT '[]',
    tags            JSONB NOT NULL DEFAULT '[]',
    source          TEXT NOT NULL
        CHECK (source IN ('planning', 'interview', 'pr_review', 'manual')),
    epic_id         TEXT,
    supersedes      JSONB NOT NULL DEFAULT '[]',
    superseded_by   UUID,
    created_at      TIMESTAMPTZ NOT NULL,
    db_written_at   TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    created_by      TEXT NOT NULL
);

-- =============================================================================
-- INDEXES: decision_store
-- =============================================================================

-- Hot path: list active decisions for a given domain + layer (partial index).
CREATE INDEX IF NOT EXISTS idx_decision_store_active_scope
    ON decision_store (scope_domain, scope_layer)
    WHERE status = 'ACTIVE';

-- Cursor-based pagination ordered by creation time, breaking ties on decision_id.
CREATE INDEX IF NOT EXISTS idx_decision_store_created_at_id
    ON decision_store (created_at DESC, decision_id DESC);

-- Lookup decisions belonging to a specific epic (sparse — many rows have NULL epic_id).
CREATE INDEX IF NOT EXISTS idx_decision_store_epic_id
    ON decision_store (epic_id)
    WHERE epic_id IS NOT NULL;

-- Lookup all decisions sharing a correlation context.
CREATE INDEX IF NOT EXISTS idx_decision_store_correlation
    ON decision_store (correlation_id);

-- JSONB containment / overlap queries: "which decisions affect service X?"
CREATE INDEX IF NOT EXISTS idx_decision_store_scope_services
    ON decision_store USING GIN (scope_services);

-- =============================================================================
-- COMMENTS: decision_store
-- =============================================================================

COMMENT ON TABLE decision_store IS
    'Canonical record of architectural, design, and planning decisions captured '
    'by the ONEX decision management system (OMN-2764).';

COMMENT ON COLUMN decision_store.decision_id IS
    'Stable UUID assigned by the application layer before the row is written. '
    'Not DB-generated so that IDs can be propagated deterministically through '
    'events before persistence.';

COMMENT ON COLUMN decision_store.correlation_id IS
    'Links this decision to the originating pipeline / session correlation context.';

COMMENT ON COLUMN decision_store.status IS
    'Lifecycle status: PROPOSED → ACTIVE → SUPERSEDED | DEPRECATED.';

COMMENT ON COLUMN decision_store.scope_services IS
    'JSONB array of service names affected by this decision.  '
    'Queried via GIN index for containment / overlap lookups.';

COMMENT ON COLUMN decision_store.supersedes IS
    'JSONB array of decision_id UUIDs that this decision replaces.';

COMMENT ON COLUMN decision_store.superseded_by IS
    'UUID of the decision that replaces this one (NULL while still active).';

COMMENT ON COLUMN decision_store.db_written_at IS
    'Server-side write timestamp set automatically by the database (DEFAULT NOW()).  '
    'Distinct from created_at which is the application-supplied logical creation time.';

-- =============================================================================
-- TABLE: decision_conflicts
-- =============================================================================

CREATE TABLE IF NOT EXISTS decision_conflicts (
    conflict_id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    decision_min_id       UUID NOT NULL REFERENCES decision_store (decision_id),
    decision_max_id       UUID NOT NULL REFERENCES decision_store (decision_id),
    -- Normalise pair order to prevent (A,B) and (B,A) duplicates.
    CONSTRAINT chk_conflict_pair_order CHECK (decision_min_id < decision_max_id),
    CONSTRAINT uk_conflict_pair UNIQUE (decision_min_id, decision_max_id),
    structural_confidence DECIMAL(4,3) NOT NULL,
    semantic_verdict      BOOLEAN,
    semantic_explanation  TEXT,
    final_severity        TEXT NOT NULL
        CHECK (final_severity IN ('HIGH', 'MEDIUM', 'LOW')),
    status                TEXT NOT NULL DEFAULT 'OPEN'
        CHECK (status IN ('OPEN', 'DISMISSED', 'RESOLVED')),
    detected_at           TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    resolved_at           TIMESTAMPTZ,
    resolved_by           TEXT,
    resolution_note       TEXT
);

-- =============================================================================
-- INDEXES: decision_conflicts
-- =============================================================================

-- List open conflicts ordered by detection time (partial — only unresolved rows).
CREATE INDEX IF NOT EXISTS idx_decision_conflicts_open
    ON decision_conflicts (detected_at DESC)
    WHERE status = 'OPEN';

-- =============================================================================
-- COMMENTS: decision_conflicts
-- =============================================================================

COMMENT ON TABLE decision_conflicts IS
    'Tracks pairs of decisions with detected structural or semantic conflicts.  '
    'Pairs are stored with decision_min_id < decision_max_id to prevent duplicates.';

COMMENT ON COLUMN decision_conflicts.structural_confidence IS
    'Confidence score [0.000–1.000] from structural conflict detection heuristic.';

COMMENT ON COLUMN decision_conflicts.semantic_verdict IS
    'TRUE = confirmed conflict, FALSE = no conflict, NULL = not yet evaluated.';

COMMENT ON COLUMN decision_conflicts.final_severity IS
    'Resolved severity after combining structural and semantic signals.';
