# SPDX-License-Identifier: MIT
# Copyright (c) 2025 OmniNode Team
#
# ONEX Node Contract
# Node: NodeRegistryEffect
#
# This contract defines the interface for the Registry Effect node,
# which handles dual-backend node registration against Consul and PostgreSQL.
# The node uses declarative operation routing to dispatch operations to
# backend-specific handlers.
# Contract identifiers
name: "node_registry_effect"
contract_name: "node_registry_effect"
node_name: "node_registry_effect"
# Version (semantic versioning)
version:
  major: 1
  minor: 1
  patch: 0
contract_version:
  major: 1
  minor: 1
  patch: 0
node_version:
  major: 1
  minor: 1
  patch: 0
# Node type
node_type: "EFFECT"
# Description
description: >
  Effect node for dual-backend node registration. Executes registration operations against both Consul (service discovery) and PostgreSQL (registration record persistence), with support for partial failure handling and targeted retries. Uses declarative operation routing to dispatch to backend-specific handlers.

# Strongly typed I/O models
input_model:
  name: "ModelRegistryRequest"
  module: "omnibase_infra.nodes.node_registry_effect.models"
  description: "Input model containing operation type and registration parameters."
output_model:
  name: "ModelRegistryResponse"
  module: "omnibase_infra.nodes.node_registry_effect.models"
  description: "Output model containing backend status and registration outcome."
# =============================================================================
# OPERATION ROUTING (Declarative Handler Dispatch)
# =============================================================================
# This section defines how operations are routed to backend-specific handlers.
# The routing strategy determines handler selection based on operation type
# and target backend.
#
# Design Rationale:
#   - Parallel execution for independent backends (Consul + Postgres)
#   - Partial failure handling allows one backend to succeed even if other fails
#   - Each handler is responsible for a single backend operation
#
# Execution Flow:
#   1. Receive ModelRegistryRequest with operation type
#   2. Route to all matching handlers based on operation
#   3. Execute handlers in parallel (for dual-backend operations)
#   4. Aggregate results with partial failure handling
#   5. Return ModelRegistryResponse with combined status
#
# ┌─────────────────────────────────────────────────────────────────────────┐
# │                    OPERATION ROUTING ARCHITECTURE                       │
# ├─────────────────────────────────────────────────────────────────────────┤
# │                                                                         │
# │  ┌────────────────────┐                                                 │
# │  │ ModelRegistryRequest│                                                │
# │  │   operation: "X"   │                                                 │
# │  └─────────┬──────────┘                                                 │
# │            │                                                            │
# │            ▼                                                            │
# │  ┌─────────────────────┐                                                │
# │  │  Operation Router   │  routing_strategy: "operation_match"          │
# │  │  (Contract-Driven)  │  Matches operation field to handlers           │
# │  └─────────┬───────────┘                                                │
# │            │                                                            │
# │            │ operation == "register_node"                               │
# │            │                                                            │
# │     ┌──────┴──────┐     execution_mode: "parallel"                      │
# │     │             │     (asyncio.gather)                                │
# │     ▼             ▼                                                     │
# │ ┌────────────┐ ┌────────────┐                                           │
# │ │  Handler   │ │  Handler   │                                           │
# │ │  Consul    │ │  Postgres  │                                           │
# │ │  Register  │ │  Upsert    │                                           │
# │ └─────┬──────┘ └─────┬──────┘                                           │
# │       │              │                                                  │
# │       ▼              ▼                                                  │
# │ ┌──────────────────────────┐                                            │
# │ │   Result Aggregator      │  aggregation_strategy: "all_or_partial"   │
# │ │   partial_failure: true  │                                            │
# │ └────────────┬─────────────┘                                            │
# │              │                                                          │
# │              ▼                                                          │
# │  ┌─────────────────────────┐                                            │
# │  │  ModelRegistryResponse  │  status: "success"/"partial"/"failed"     │
# │  │  consul_result: Result  │  consul_result.success: bool               │
# │  │  postgres_result: Result│  postgres_result.success: bool             │
# │  └─────────────────────────┘                                            │
# │                                                                         │
# └─────────────────────────────────────────────────────────────────────────┘
#
# Parallel Execution Behavior:
#   When execution_mode is "parallel", handlers for the same operation execute
#   concurrently using asyncio.gather(). For dual-backend operations like
#   "register_node", both HandlerConsulRegister and HandlerPostgresUpsert run
#   simultaneously, reducing total latency to max(consul_time, postgres_time)
#   rather than consul_time + postgres_time.
#
#   Partial failure (partial_failure_handling: true) means if Consul succeeds
#   but PostgreSQL fails (or vice versa), the operation returns status="partial"
#   with the successful backend's result.success=true and the failed backend's
#   result.success=false, allowing callers to retry the failed backend
#   via the "retry_partial_failure" operation.
#
# Handler Responsibility:
#   Each handler manages its own retry logic using the retry_policy defined
#   in error_handling. The orchestration layer dispatches once per handler
#   and delegates retry behavior to the handlers themselves.
# =============================================================================
operation_routing:
  routing_strategy: "operation_match"
  operations:
    # Register Node - Consul Backend
    # Registers service with Consul for service discovery.
    # Uses health check endpoint for automated liveness monitoring.
    - operation: "register_node"
      handler:
        name: "HandlerConsulRegister"
        module: "omnibase_infra.nodes.node_registry_effect.handlers.handler_consul_register"
      backend: "consul"
      description: "Register node with Consul service discovery"
      output_fields:
        - consul_registered
        - consul_service_id
    # Register Node - PostgreSQL Backend
    # Persists registration record to PostgreSQL for durability.
    # Uses upsert semantics for idempotent re-registration.
    - operation: "register_node"
      handler:
        name: "HandlerPostgresUpsert"
        module: "omnibase_infra.nodes.node_registry_effect.handlers.handler_postgres_upsert"
      backend: "postgres"
      description: "Persist node registration to PostgreSQL"
      output_fields:
        - postgres_registered
        - registration_id
    # Deregister Node - Consul Backend
    # Removes service from Consul to stop routing traffic.
    - operation: "deregister_node"
      handler:
        name: "HandlerConsulDeregister"
        module: "omnibase_infra.nodes.node_registry_effect.handlers.handler_consul_deregister"
      backend: "consul"
      description: "Deregister node from Consul service discovery"
      output_fields:
        - consul_deregistered
    # Deregister Node - PostgreSQL Backend
    # Marks registration record as inactive in PostgreSQL.
    - operation: "deregister_node"
      handler:
        name: "HandlerPostgresDeactivate"
        module: "omnibase_infra.nodes.node_registry_effect.handlers.handler_postgres_deactivate"
      backend: "postgres"
      description: "Mark node registration as inactive in PostgreSQL"
      output_fields:
        - postgres_deregistered
    # Retry Partial Failure - Targeted Backend
    # Retries a specific backend after partial failure.
    # Uses idempotency key to ensure safe retry semantics.
    - operation: "retry_partial_failure"
      handler:
        name: "HandlerPartialRetry"
        module: "omnibase_infra.nodes.node_registry_effect.handlers.handler_partial_retry"
      backend: "dynamic"
      description: "Retry registration for specific backend after partial failure"
      dynamic_backend_field: "target_backend"
      output_fields:
        - success
        - backend_status
  # Execution configuration
  execution_mode: "parallel"
  partial_failure_handling: true
  aggregation_strategy: "all_or_partial"
# =============================================================================
# ERROR HANDLING (Circuit Breaker + Retry + Sanitization)
# =============================================================================
# Error handling configuration following ONEX infrastructure patterns.
# Uses circuit breakers for backend protection and retry policies for
# transient failure recovery.
#
# Error Flow:
#   1. Operation fails -> Check if error is retriable
#   2. Retry with exponential backoff if retriable
#   3. After max retries, check circuit breaker state
#   4. Open circuit if failure threshold exceeded
#   5. Sanitize error before logging/returning
# =============================================================================
error_handling:
  # Circuit breaker configuration
  # Prevents cascading failures by stopping requests to failing backends.
  circuit_breaker:
    enabled: true
    failure_threshold: 5
    reset_timeout_ms: 60000
    half_open_max_requests: 3
    per_backend: true
    backends:
      - name: "consul"
        failure_threshold: 5
        reset_timeout_ms: 60000
      - name: "postgres"
        failure_threshold: 5
        reset_timeout_ms: 60000
  # Retry policy with exponential backoff
  # Handles transient infrastructure failures.
  #
  # IMPORTANT: Orchestration Layer Retry Behavior
  #   This retry_policy is declarative configuration consumed by handlers.
  #   At the orchestration layer, the effective retry count is always 0 -
  #   the orchestrator dispatches to handlers exactly once per operation.
  #   Individual handlers are responsible for implementing retry loops using
  #   these settings (max_retries, delays, exponential backoff).
  #
  #   This design ensures:
  #   - Clear separation of concerns (orchestrator routes, handlers retry)
  #   - Per-backend retry isolation (Consul retries don't affect Postgres)
  #   - Consistent retry behavior across all handler implementations
  retry_policy:
    max_retries: 3
    initial_delay_ms: 100
    max_delay_ms: 5000
    exponential_base: 2
    retry_on:
      - "InfraConnectionError"
      - "InfraTimeoutError"
      - "InfraUnavailableError"
  # Error sanitization
  # Removes sensitive information from error messages before logging.
  error_sanitization:
    enabled: true
    utility: "omnibase_infra.utils.util_error_sanitization"
    sanitize_patterns:
      - "password"
      - "secret"
      - "token"
      - "api_key"
      - "connection_string"
  # Error type definitions
  error_types:
    - name: "InfraConnectionError"
      description: "Failed to connect to backend service"
      recoverable: true
      retry_strategy: "exponential_backoff"
    - name: "InfraTimeoutError"
      description: "Backend operation timed out"
      recoverable: true
      retry_strategy: "exponential_backoff"
    - name: "InfraAuthenticationError"
      description: "Authentication failed with backend"
      recoverable: false
      retry_strategy: "none"
    - name: "InfraUnavailableError"
      description: "Backend service is unavailable (circuit open)"
      recoverable: true
      retry_strategy: "exponential_backoff"
  # Error codes used in ModelBackendResult.error_code field
  # These codes provide programmatic error categorization for handlers.
  # Each code maps to a specific operation failure scenario.
  error_codes:
    # Consul backend error codes
    - code: "CONSUL_REGISTRATION_ERROR"
      backend: "consul"
      operation: "register_node"
      description: "Consul service registration failed (non-connection error)"
    - code: "CONSUL_DEREGISTRATION_ERROR"
      backend: "consul"
      operation: "deregister_node"
      description: "Consul service deregistration failed (non-connection error)"
    - code: "CONSUL_CONNECTION_ERROR"
      backend: "consul"
      operation: "all"
      description: "Connection to Consul server failed"
    # PostgreSQL backend error codes
    - code: "POSTGRES_UPSERT_ERROR"
      backend: "postgres"
      operation: "register_node"
      description: "PostgreSQL upsert operation failed (non-connection error)"
    - code: "POSTGRES_DEACTIVATION_ERROR"
      backend: "postgres"
      operation: "deregister_node"
      description: "PostgreSQL deactivation operation failed (non-connection error)"
    - code: "POSTGRES_CONNECTION_ERROR"
      backend: "postgres"
      operation: "all"
      description: "Connection to PostgreSQL server failed"
    # Retry operation error codes
    - code: "INVALID_TARGET_BACKEND"
      backend: "dynamic"
      operation: "retry_partial_failure"
      description: "Invalid target_backend specified for retry (must be 'consul' or 'postgres')"
# IO operations (EFFECT node specific)
# Note: Input fields reference ModelRegistryRequest, output fields reference ModelRegistryResponse
io_operations:
  - operation: "register_node"
    description: "Register a node with both Consul and PostgreSQL backends"
    input_fields:
      - node_id
      - node_type
      - node_version
      - correlation_id
      - service_name
      - endpoints
      - tags
      - metadata
      - health_check_config
      - timestamp
    output_fields:
      - status
      - node_id
      - correlation_id
      - consul_result
      - postgres_result
      - processing_time_ms
      - timestamp
      - error_summary
  - operation: "deregister_node"
    description: "Deregister a node from both backends"
    input_fields:
      - node_id
      - node_type
      - node_version
      - correlation_id
      - timestamp
    output_fields:
      - status
      - node_id
      - correlation_id
      - consul_result
      - postgres_result
      - processing_time_ms
      - timestamp
      - error_summary
  - operation: "retry_partial_failure"
    description: "Retry registration for a specific backend after partial failure"
    input_fields:
      - node_id
      - target_backend
      - idempotency_key
    output_fields:
      - status
      - node_id
      - correlation_id
      - consul_result
      - postgres_result
      - processing_time_ms
      - timestamp
      - error_summary
# Dependencies (protocols this node requires)
dependencies:
  - name: "protocol_consul_client"
    type: "protocol"
    class_name: "ProtocolConsulClient"
    module: "omnibase_infra.nodes.effects.protocol_consul_client"
    description: "Consul service discovery operations"
  - name: "protocol_postgres_adapter"
    type: "protocol"
    class_name: "ProtocolPostgresAdapter"
    module: "omnibase_infra.nodes.effects.protocol_postgres_adapter"
    description: "PostgreSQL registration persistence"
  - name: "protocol_effect_idempotency_store"
    type: "protocol"
    class_name: "ProtocolEffectIdempotencyStore"
    module: "omnibase_infra.nodes.effects.protocol_effect_idempotency_store"
    description: "Idempotency tracking for retry safety"
  - name: "protocol_circuit_breaker_aware"
    type: "protocol"
    class_name: "ProtocolCircuitBreakerAware"
    module: "omnibase_infra.mixins.protocol_circuit_breaker_aware"
    description: "Circuit breaker awareness for backend protection"
# Capabilities provided by this node
capabilities:
  - name: "dual_backend_registration"
    description: "Register nodes with both Consul and PostgreSQL simultaneously"
  - name: "partial_failure_handling"
    description: "Handle and recover from partial registration failures"
  - name: "targeted_retry"
    description: "Retry specific backend operations independently"
  - name: "idempotent_operations"
    description: "Ensure operations are idempotent via idempotency store"
  - name: "circuit_breaker_protection"
    description: "Protect backends with circuit breaker pattern"
  - name: "parallel_execution"
    description: "Execute backend operations in parallel for reduced latency"
# Model definitions
# These definitions must exactly match the Pydantic models in:
#   - omnibase_infra.nodes.effects.models.model_registry_request
#   - omnibase_infra.nodes.effects.models.model_registry_response
#   - omnibase_infra.nodes.effects.models.model_backend_result
definitions:
  ModelRegistryRequest:
    type: object
    description: "Request model for dual-backend registration operations"
    frozen: true
    extra: "forbid"
    properties:
      node_id:
        type: uuid
        description: "Unique identifier for the node being registered"
      node_type:
        type: enum
        enum_class: "EnumNodeKind"
        module: "omnibase_core.enums.enum_node_kind"
        description: "Type of ONEX node (effect, compute, reducer, orchestrator)"
        enum:
          - "effect"
          - "compute"
          - "reducer"
          - "orchestrator"
      node_version:
        type: string
        description: "Semantic version of the node"
      correlation_id:
        type: uuid
        description: "Correlation ID for distributed tracing"
        default_factory: "uuid4"
      service_name:
        type: string
        nullable: true
        description: "Name for service discovery registration"
      endpoints:
        type: object
        key_type: string
        value_type: string
        description: "Dict of endpoint type to URL (e.g., {'health': 'http://...'})"
        default_factory: "dict"
      tags:
        type: array
        items:
          type: string
        description: "List of tags for service discovery"
        default_factory: "list"
      metadata:
        type: object
        key_type: string
        value_type: string
        description: "Additional metadata for the registration record"
        default_factory: "dict"
      health_check_config:
        type: object
        key_type: string
        value_type: string
        nullable: true
        description: "Optional health check configuration for Consul"
      timestamp:
        type: datetime
        description: "When this request was created (must be timezone-aware, explicitly provided)"
        validation:
          - name: "validate_timestamp_timezone_aware"
            description: "Validates that timestamp has timezone info"
    required:
      - node_id
      - node_type
      - node_version
      - timestamp
  ModelBackendResult:
    type: object
    description: "Result of an individual backend operation (Consul or PostgreSQL)"
    frozen: true
    extra: "forbid"
    properties:
      success:
        type: boolean
        description: "Whether the backend operation completed successfully"
      error:
        type: string
        nullable: true
        description: "Sanitized error message if success is False"
      error_code:
        type: string
        nullable: true
        description: "Error code for programmatic handling (e.g., DATABASE_CONNECTION_ERROR)"
      duration_ms:
        type: float
        description: "Time taken for the operation in milliseconds"
        default: 0.0
        ge: 0.0
      retries:
        type: integer
        description: "Number of retry attempts made before final result. Note: At the orchestration layer, this value is always 0 because the orchestrator dispatches once per handler. Individual handlers may implement retry logic internally using the retry_policy configuration, but this field reflects handler-level retries, not orchestrator-level."
        default: 0
        ge: 0
      backend_id:
        type: string
        nullable: true
        description: "Optional identifier for the backend instance"
      correlation_id:
        type: uuid
        nullable: true
        description: "Correlation ID for tracing the operation"
    required:
      - success
  ModelRegistryResponse:
    type: object
    description: "Response model for dual-backend registration operations with partial failure support"
    frozen: true
    extra: "forbid"
    properties:
      status:
        type: string
        description: "Overall status: success (both succeeded), partial (one succeeded), or failed (both failed)"
        enum:
          - "success"
          - "partial"
          - "failed"
      node_id:
        type: uuid
        description: "UUID of the node that was registered"
      correlation_id:
        type: uuid
        description: "Correlation ID for distributed tracing"
      consul_result:
        type: ref
        ref: "ModelBackendResult"
        description: "Result of the Consul registration operation"
      postgres_result:
        type: ref
        ref: "ModelBackendResult"
        description: "Result of the PostgreSQL upsert operation"
      processing_time_ms:
        type: float
        description: "Total time for the dual-registration operation in milliseconds"
        default: 0.0
        ge: 0.0
      timestamp:
        type: datetime
        description: "When this response was created (must be explicitly provided)"
      error_summary:
        type: string
        nullable: true
        description: "Aggregated error message for failed operations (e.g., 'Consul: error; PostgreSQL: error')"
    required:
      - status
      - node_id
      - correlation_id
      - consul_result
      - postgres_result
      - timestamp
# Health check configuration
health_check:
  enabled: true
  endpoint: "/health"
  interval_seconds: 30
  backends:
    - name: "consul"
      check_type: "http"
      endpoint: "/v1/status/leader"
    - name: "postgres"
      check_type: "connection"
      timeout_ms: 5000
# Metadata
metadata:
  author: "OmniNode Team"
  license: "MIT"
  created: "2025-01-01"
  updated: "2026-01-07"
  tags:
    - effect
    - registration
    - consul
    - postgresql
    - dual-backend
    - idempotency
    - circuit-breaker
    - parallel-execution
