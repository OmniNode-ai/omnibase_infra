# SPDX-License-Identifier: MIT
# Copyright (c) 2026 OmniNode Team
#
# TopicEnumGenerator — per-producer Python enum file renderer.
#
# Consumes validated ModelContractTopicEntry objects from ContractTopicExtractor
# and renders per-producer Python enum files. Does NOT re-validate topic strings;
# all validation is the extractor's responsibility (OMN-2963).
#
# Ticket: OMN-2964
#
# ============================================================================
# NORMALIZATION RULES
# ============================================================================
#
# Given a ModelContractTopicEntry with fields: kind, event_name, version
# (guaranteed valid by extractor — ^[a-z0-9._-]+$ for event_name):
#
#   1. Replace ALL '-' and '.' in event_name with '_'
#   2. Uppercase the result → base_key
#   3. Prepend kind prefix:
#      - "evt"    → "EVT_"
#      - "cmd"    → "CMD_"
#      - "intent" → "INTENT_"
#   4. Append version suffix: "_V{N}" where N is the digit(s) from version "v{N}"
#
# Examples:
#   topic "onex.evt.platform.intent-classified.v1"
#     event_name="intent-classified", kind="evt", version="v1"
#     base_key = "INTENT_CLASSIFIED"
#     full_key = "EVT_INTENT_CLASSIFIED_V1"
#
#   topic "onex.cmd.platform.intent-query-session.v1"
#     event_name="intent-query-session", kind="cmd", version="v1"
#     base_key = "INTENT_QUERY_SESSION"
#     full_key = "CMD_INTENT_QUERY_SESSION_V1"
#
#   topic "onex.intent.platform.runtime-tick.v1"
#     event_name="runtime-tick", kind="intent", version="v1"
#     base_key = "RUNTIME_TICK"
#     full_key = "INTENT_RUNTIME_TICK_V1"
#
#   topic "onex.evt.platform.fsm-state-transitions.v2"
#     event_name="fsm-state-transitions", kind="evt", version="v2"
#     base_key = "FSM_STATE_TRANSITIONS"
#     full_key = "EVT_FSM_STATE_TRANSITIONS_V2"
#
# ============================================================================
# OUTPUT FILE STRUCTURE
# ============================================================================
#
# For each producer, one enum file is generated:
#   enum_{producer_underscored}_topic.py
#   (where producer hyphens are replaced with underscores for the filename)
#
# The enum class is named: Enum{ProducerTitleCase}Topic
#   e.g., producer "platform" → EnumPlatformTopic
#         producer "my-service" → EnumMyServiceTopic
#
# An __init__.py is generated at the output root with relative imports:
#   from .enum_platform_topic import EnumPlatformTopic
#   from .enum_my_service_topic import EnumMyServiceTopic
#
# The __init__.py does NOT export a helper mapping (producer → enum class).
#
# ============================================================================

from __future__ import annotations

import textwrap
from pathlib import Path
from typing import Literal

from omnibase_infra.tools.contract_topic_extractor import ModelContractTopicEntry

# ---------------------------------------------------------------------------
# Kind prefix map
# ---------------------------------------------------------------------------

_KIND_PREFIX: dict[str, str] = {
    "evt": "EVT_",
    "cmd": "CMD_",
    "intent": "INTENT_",
}

# File header template (filled per producer)
_FILE_HEADER = """\
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 OmniNode Team
#
# AUTO-GENERATED FILE — DO NOT EDIT MANUALLY
# Generated by TopicEnumGenerator (OMN-2964)
# Source: contract.yaml files under src/omnibase_infra/nodes/
#
# To regenerate, run:
#   uv run python scripts/generate_topic_enums.py
#
from enum import Enum


class {class_name}(str, Enum):
    \"\"\"Kafka topic enum for producer: {producer}.

    All values are raw topic strings as declared in contract.yaml.
    Members are sorted by (kind, event_name, version).
    \"\"\"
"""

_MEMBER_TEMPLATE = "    {key} = {value!r}  # {topic}"

_INIT_HEADER = """\
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 OmniNode Team
#
# AUTO-GENERATED FILE — DO NOT EDIT MANUALLY
# Generated by TopicEnumGenerator (OMN-2964)
#
# Per-producer Kafka topic enums.
# To regenerate, run:
#   uv run python scripts/generate_topic_enums.py
#
"""


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _normalize_key(entry: ModelContractTopicEntry) -> str:
    """
    Compute the enum member key for a topic entry.

    Normalization:
      1. Replace '-' and '.' in event_name with '_'
      2. Uppercase → base_key
      3. Prepend kind prefix (EVT_ / CMD_ / INTENT_)
      4. Append _V{N} from version field
    """
    base_key = entry.event_name.replace("-", "_").replace(".", "_").upper()
    prefix = _KIND_PREFIX[entry.kind]
    version_suffix = "_V" + entry.version[1:]  # "v1" → "_V1"
    return f"{prefix}{base_key}{version_suffix}"


def _producer_to_class_name(producer: str) -> str:
    """
    Convert a producer string to an enum class name.

    "platform" → "EnumPlatformTopic"
    "my-service" → "EnumMyServiceTopic"
    """
    parts = producer.replace("-", " ").title().replace(" ", "")
    return f"Enum{parts}Topic"


def _producer_to_filename(producer: str) -> str:
    """
    Convert a producer string to a Python module filename.

    "platform" → "enum_platform_topic.py"
    "my-service" → "enum_my_service_topic.py"
    """
    safe = producer.replace("-", "_")
    return f"enum_{safe}_topic.py"


def _sort_key(entry: ModelContractTopicEntry) -> tuple[str, str, str]:
    """Sort key: (kind, event_name, version) for deterministic ordering."""
    return (entry.kind, entry.event_name, entry.version)


# ---------------------------------------------------------------------------
# Generator
# ---------------------------------------------------------------------------


class TopicEnumGenerator:
    """
    Render per-producer Python enum files from validated topic entries.

    Accepts a list of ModelContractTopicEntry objects (output of
    ContractTopicExtractor) and returns a dict mapping output path → file
    content (str). The caller is responsible for writing to disk.

    Does NOT re-validate topic strings — all validation is delegated to
    ContractTopicExtractor (OMN-2963).
    """

    def render(
        self,
        entries: list[ModelContractTopicEntry],
        output_dir: Path = Path("src/omnibase_infra/topics/generated"),
    ) -> dict[Path, str]:
        """
        Render enum files for each producer in entries.

        Args:
            entries: Validated topic entries from ContractTopicExtractor.
            output_dir: Root directory for generated files (used as key prefix
                        in the returned dict). Defaults to the canonical location.

        Returns:
            dict[Path, str] mapping output file path → file content.
            Includes one enum file per producer AND an __init__.py.

        Raises:
            RuntimeError: If two entries in the same producer group normalize
                          to the same enum member key (collision).
        """
        if not entries:
            return {}

        # Group by producer
        by_producer: dict[str, list[ModelContractTopicEntry]] = {}
        for entry in entries:
            by_producer.setdefault(entry.producer, []).append(entry)

        result: dict[Path, str] = {}
        # class_names ordered by producer (sorted) for __init__.py
        class_exports: list[tuple[str, str]] = []  # (filename_stem, class_name)

        for producer in sorted(by_producer):
            producer_entries = sorted(by_producer[producer], key=_sort_key)
            class_name = _producer_to_class_name(producer)
            filename = _producer_to_filename(producer)
            file_path = output_dir / filename

            # Collision detection on normalized keys
            seen_keys: dict[str, str] = {}  # key → first topic that claimed it
            members: list[tuple[str, str]] = []  # (key, topic_value)
            for entry in producer_entries:
                key = _normalize_key(entry)
                if key in seen_keys:
                    raise RuntimeError(
                        f"Enum key collision for producer {producer!r}: "
                        f"normalized key {key!r} is claimed by both "
                        f"{seen_keys[key]!r} and {entry.topic!r}. "
                        f"Rename one topic's event-name to resolve."
                    )
                seen_keys[key] = entry.topic
                members.append((key, entry.topic))

            # Render file content
            content = _FILE_HEADER.format(class_name=class_name, producer=producer)
            for key, topic_value in members:
                content += _MEMBER_TEMPLATE.format(
                    key=key, value=topic_value, topic=topic_value
                )
                content += "\n"
            content += "\n"  # trailing newline

            result[file_path] = content
            class_exports.append((filename[:-3], class_name))  # strip .py

        # Render __init__.py
        init_path = output_dir / "__init__.py"
        init_content = _INIT_HEADER
        for stem, class_name in class_exports:
            init_content += f"from .{stem} import {class_name}\n"
        init_content += "\n"

        result[init_path] = init_content

        return result

    def render_member_key(self, entry: ModelContractTopicEntry) -> str:
        """
        Public access to key normalization for external callers.

        Normalizes a single entry to its enum member key string.
        Useful for testing and validation without rendering a full file.
        """
        return _normalize_key(entry)

    def class_name_for_producer(self, producer: str) -> str:
        """Return the enum class name for a given producer string."""
        return _producer_to_class_name(producer)

    def filename_for_producer(self, producer: str) -> str:
        """Return the output filename for a given producer string."""
        return _producer_to_filename(producer)

    @staticmethod
    def validate_output_dir(output_dir: Path) -> Literal[True]:
        """
        Validate the output directory path.

        The caller is responsible for creating directories; this simply checks
        that the path is absolute or relative (no validation of existence).

        Returns True always — raises TypeError if output_dir is not a Path.
        """
        if not isinstance(output_dir, Path):
            raise TypeError(f"output_dir must be a Path, got {type(output_dir)}")
        return True
