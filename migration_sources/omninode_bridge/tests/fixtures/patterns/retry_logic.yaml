# Retry Logic Pattern
name: retry_logic
category: resilience
description: Retry logic with exponential backoff for transient failures

# Applicability
node_types:
  - effect

complexity: 3
recommended_for:
  - network_operations
  - external_apis
  - temporary_failures

# Pattern Definition
code_template: |
  async def retry_with_backoff(
      func,
      max_retries: int = 3,
      initial_delay: float = 1.0,
      backoff_factor: float = 2.0,
      max_delay: float = 60.0,
      *args,
      **kwargs
  ):
      """Execute function with retry and exponential backoff."""
      delay = initial_delay
      last_exception = None

      for attempt in range(max_retries):
          try:
              return await func(*args, **kwargs)
          except Exception as e:
              last_exception = e
              if attempt < max_retries - 1:
                  logger.warning(f"Attempt {attempt + 1} failed: {e}. Retrying in {delay}s")
                  await asyncio.sleep(delay)
                  delay = min(delay * backoff_factor, max_delay)
              else:
                  logger.error(f"All {max_retries} attempts failed")

      raise last_exception

dependencies:
  - asyncio
  - logging

imports:
  - import asyncio
  - import logging

# Usage Example
example: |
  # Use retry with backoff
  try:
      result = await retry_with_backoff(
          external_api_call,
          max_retries=3,
          initial_delay=1.0,
          backoff_factor=2.0,
          param1="value1"
      )
  except Exception as e:
      logger.error(f"Failed after all retries: {e}")
