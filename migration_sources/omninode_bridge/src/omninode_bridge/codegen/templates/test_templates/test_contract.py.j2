#!/usr/bin/env python3
"""
Contract compliance tests for {{ node_name }}.

Generated by NodeTestGeneratorEffect.
ONEX v2.0 Compliance: Validates contract adherence and ONEX standards.

Contract File: {{ contract_file }}
Node Type: {{ node_type }}
"""

import pytest
import yaml
from pathlib import Path
from inspect import signature, iscoroutinefunction

from omnibase_core.models.contracts.model_contract_{{ node_type }} import ModelContract{{ node_type.capitalize() }}
from omnibase_core.enums.enum_node_type import EnumNodeType
from omnibase_core.models.core import ModelContainer

from {{ module_path }} import {{ node_name }}


# ============================================================================
# CONTRACT COMPLIANCE MARKERS
# ============================================================================

pytestmark = [
    pytest.mark.contract,
    pytest.mark.onex_compliance,
]


# ============================================================================
# FIXTURES
# ============================================================================

@pytest.fixture(scope="module")
def contract_file_path():
    """Path to contract YAML file."""
    return Path("{{ contract_file }}")


@pytest.fixture(scope="module")
def contract_data(contract_file_path):
    """Load contract YAML data."""
    if not contract_file_path.exists():
        pytest.skip(f"Contract file not found: {contract_file_path}")

    with open(contract_file_path) as f:
        return yaml.safe_load(f)


@pytest.fixture(scope="module")
def contract_model(contract_data):
    """Create validated contract model from YAML."""
    # Convert node_type string to enum
    contract_data["node_type"] = EnumNodeType[contract_data["node_type"].upper()]

    return ModelContract{{ node_type.capitalize() }}.model_validate(contract_data)


@pytest.fixture
def node_instance():
    """Create node instance for contract testing."""
    container = ModelContainer()
    return {{ node_name }}(container)


# ============================================================================
# CONTRACT STRUCTURE TESTS
# ============================================================================

{% if test_contract.include_docstrings %}
def test_contract_file_exists(contract_file_path):
    """
    Test: Contract YAML file exists and is readable.

    Validates:
    - Contract file exists at expected location
    - File is readable
    - File is not empty
    """
    assert contract_file_path.exists(), f"Contract file should exist: {contract_file_path}"
    assert contract_file_path.is_file(), f"Contract path should be a file: {contract_file_path}"
    assert contract_file_path.stat().st_size > 0, "Contract file should not be empty"


def test_contract_yaml_valid(contract_data):
    """
    Test: Contract YAML is well-formed and valid.

    Validates:
    - YAML parses without errors
    - Contains required top-level keys
    - Data types are correct
    """
    assert isinstance(contract_data, dict), "Contract should be a dictionary"
    assert len(contract_data) > 0, "Contract should not be empty"


def test_contract_required_fields(contract_data):
    """
    Test: Contract contains all required ONEX v2.0 fields.

    Validates:
    - name (string)
    - version (dict with major/minor/patch)
    - description (string)
    - node_type (string)
    - input_model (string)
    - output_model (string)
    - tool_specification (dict)
    """
    required_fields = [
        "name",
        "version",
        "description",
        "node_type",
        "input_model",
        "output_model",
        "tool_specification",
    ]

    for field in required_fields:
        assert field in contract_data, f"Contract missing required field: {field}"
        assert contract_data[field] is not None, f"Contract field cannot be None: {field}"


def test_contract_version_format(contract_data):
    """
    Test: Contract version follows semantic versioning.

    Validates:
    - version is a dict
    - Contains major, minor, patch
    - All are non-negative integers
    """
    assert "version" in contract_data
    version = contract_data["version"]

    assert isinstance(version, dict), "Version should be a dictionary"
    assert "major" in version, "Version missing 'major'"
    assert "minor" in version, "Version missing 'minor'"
    assert "patch" in version, "Version missing 'patch'"

    assert isinstance(version["major"], int), "Major version should be integer"
    assert isinstance(version["minor"], int), "Minor version should be integer"
    assert isinstance(version["patch"], int), "Patch version should be integer"

    assert version["major"] >= 0, "Major version should be non-negative"
    assert version["minor"] >= 0, "Minor version should be non-negative"
    assert version["patch"] >= 0, "Patch version should be non-negative"


def test_contract_node_type_valid(contract_data):
    """
    Test: Contract node_type is valid ONEX type.

    Validates:
    - node_type is one of: EFFECT, COMPUTE, REDUCER, ORCHESTRATOR
    - Matches expected node type: {{ node_type.upper() }}
    """
    assert "node_type" in contract_data
    node_type = contract_data["node_type"]

    valid_types = ["EFFECT", "COMPUTE", "REDUCER", "ORCHESTRATOR"]
    assert node_type.upper() in valid_types, f"Invalid node_type: {node_type}"

    # Verify matches expected type
    assert node_type.upper() == "{{ node_type.upper() }}", \
        f"Contract node_type '{node_type}' does not match expected '{{ node_type.upper() }}'"


def test_contract_tool_specification(contract_data):
    """
    Test: Contract tool_specification is complete.

    Validates:
    - tool_specification exists
    - Contains tool_name
    - Contains main_tool_class
    - main_tool_class points to correct class
    """
    assert "tool_specification" in contract_data
    tool_spec = contract_data["tool_specification"]

    assert isinstance(tool_spec, dict), "tool_specification should be a dictionary"
    assert "tool_name" in tool_spec, "tool_specification missing 'tool_name'"
    assert "main_tool_class" in tool_spec, "tool_specification missing 'main_tool_class'"

    # Verify main_tool_class references this node
    assert "{{ node_name }}" in tool_spec["main_tool_class"], \
        f"main_tool_class should reference {{ node_name }}"
{% else %}
def test_contract_file_exists(contract_file_path):
    assert contract_file_path.exists()
    assert contract_file_path.is_file()
    assert contract_file_path.stat().st_size > 0


def test_contract_yaml_valid(contract_data):
    assert isinstance(contract_data, dict)
    assert len(contract_data) > 0


def test_contract_required_fields(contract_data):
    required_fields = [
        "name", "version", "description", "node_type",
        "input_model", "output_model", "tool_specification"
    ]

    for field in required_fields:
        assert field in contract_data
        assert contract_data[field] is not None


def test_contract_version_format(contract_data):
    assert "version" in contract_data
    version = contract_data["version"]

    assert isinstance(version, dict)
    assert "major" in version and "minor" in version and "patch" in version

    assert all(isinstance(version[k], int) and version[k] >= 0
               for k in ["major", "minor", "patch"])


def test_contract_node_type_valid(contract_data):
    assert "node_type" in contract_data
    node_type = contract_data["node_type"]

    valid_types = ["EFFECT", "COMPUTE", "REDUCER", "ORCHESTRATOR"]
    assert node_type.upper() in valid_types

    assert node_type.upper() == "{{ node_type.upper() }}"


def test_contract_tool_specification(contract_data):
    assert "tool_specification" in contract_data
    tool_spec = contract_data["tool_specification"]

    assert isinstance(tool_spec, dict)
    assert "tool_name" in tool_spec and "main_tool_class" in tool_spec
    assert "{{ node_name }}" in tool_spec["main_tool_class"]
{% endif %}


# ============================================================================
# CONTRACT MODEL VALIDATION TESTS
# ============================================================================

def test_contract_model_validates(contract_model):
{% if test_contract.include_docstrings %}
    """
    Test: Contract model validates against omnibase_core schema.

    Validates:
    - Pydantic model validates successfully
    - All required fields pass validation
    - Field types are correct
    """
{% endif %}
    assert contract_model is not None
    assert isinstance(contract_model, ModelContract{{ node_type.capitalize() }})


def test_contract_model_fields(contract_model):
{% if test_contract.include_docstrings %}
    """
    Test: Contract model has all expected fields populated.

    Validates:
    - All required fields are non-None
    - Field values are correct types
    - UUIDs are valid where applicable
    """
{% endif %}
    assert contract_model.name is not None
    assert contract_model.version is not None
    assert contract_model.description is not None
    assert contract_model.node_type == EnumNodeType.{{ node_type.upper() }}
    assert contract_model.input_model is not None
    assert contract_model.output_model is not None


def test_contract_model_serialization(contract_model):
{% if test_contract.include_docstrings %}
    """
    Test: Contract model serializes correctly.

    Validates:
    - model_dump() produces valid dictionary
    - All required fields are present
    - Field values match original
    """
{% endif %}
    # Serialize to dict
    model_dict = contract_model.model_dump()
    assert model_dict is not None
    assert isinstance(model_dict, dict)
    assert len(model_dict) > 0

    # Verify key fields are present
    assert "name" in model_dict
    assert "version" in model_dict
    assert "node_type" in model_dict

    # Verify values match original
    assert model_dict["name"] == contract_model.name


# ============================================================================
# NODE IMPLEMENTATION COMPLIANCE TESTS
# ============================================================================

def test_node_class_exists(node_instance):
{% if test_contract.include_docstrings %}
    """
    Test: Node class exists and is instantiable.

    Validates:
    - Node class can be imported
    - Node instance can be created
    - Node inherits from correct base class
    """
{% endif %}
    assert node_instance is not None
    assert node_instance.__class__.__name__ == "{{ node_name }}"


def test_node_has_required_method(node_instance):
{% if test_contract.include_docstrings %}
    """
    Test: Node implements required execute method for its type.

    Validates:
    - execute_{{ node_type }}() method exists
    - Method signature is correct
    - Method is async (if required)
    """
{% endif %}
    # Verify method exists
    assert hasattr(node_instance, "execute_{{ node_type }}"), \
        f"Node should have execute_{{ node_type }}() method"

    # Get method
    execute_method = getattr(node_instance, "execute_{{ node_type }}")

    # Verify it's callable
    assert callable(execute_method), f"execute_{{ node_type }} should be callable"

    # Verify it's async
    assert iscoroutinefunction(execute_method), \
        f"execute_{{ node_type }} should be an async method"


def test_node_method_signature(node_instance):
{% if test_contract.include_docstrings %}
    """
    Test: Node execute method has correct signature.

    Validates:
    - Method accepts contract parameter
    - Contract parameter type matches node type
    - Return type is specified (if type hints used)
    """
{% endif %}
    execute_method = getattr(node_instance, "execute_{{ node_type }}")
    sig = signature(execute_method)

    # Should have at least one parameter (contract)
    params = list(sig.parameters.values())
    assert len(params) >= 1, f"execute_{{ node_type }} should accept at least 1 parameter"

    # First parameter should be 'contract'
    first_param = params[0]
    assert first_param.name == "contract", \
        f"First parameter should be 'contract', got '{first_param.name}'"

    # If type hints present, verify contract type
    if first_param.annotation != first_param.empty:
        # Note: This is a string comparison as we can't import the actual class here
        assert "Contract{{ node_type.capitalize() }}" in str(first_param.annotation), \
            f"Contract parameter should be ModelContract{{ node_type.capitalize() }}"


def test_node_implements_base_class_methods(node_instance):
{% if test_contract.include_docstrings %}
    """
    Test: Node implements all required base class methods.

    Validates:
    - Node has node_id property
    - Node has config property
    - Node inherits from correct base (Node{{ node_type.capitalize() }})
    """
{% endif %}
    # Verify node_id exists and is UUID
    assert hasattr(node_instance, "node_id"), "Node should have node_id property"
    from uuid import UUID
    assert isinstance(node_instance.node_id, UUID), "node_id should be a UUID"

    # Verify config exists
    assert hasattr(node_instance, "config"), "Node should have config property"


# ============================================================================
# ONEX PATTERN COMPLIANCE TESTS
# ============================================================================

def test_node_naming_convention():
{% if test_contract.include_docstrings %}
    """
    Test: Node follows ONEX naming conventions.

    Validates:
    - Class name: Node<Name><Type> (e.g., NodeDatabaseEffect)
    - Suffix matches node type
    - PascalCase formatting
    """
{% endif %}
    # Verify suffix matches node type
    expected_suffix = "{{ node_type.capitalize() }}"
    assert "{{ node_name }}".endswith(expected_suffix), \
        f"Node name should end with '{expected_suffix}'"

    # Verify starts with "Node"
    assert "{{ node_name }}".startswith("Node"), \
        "Node class name should start with 'Node'"

    # Verify PascalCase (no underscores, starts with capital)
    assert "_" not in "{{ node_name }}", "Node name should be PascalCase (no underscores)"
    assert "{{ node_name }}"[0].isupper(), "Node name should start with capital letter"


def test_module_structure():
{% if test_contract.include_docstrings %}
    """
    Test: Module follows ONEX directory structure.

    Validates:
    - Module path follows conventions
    - Contains node.py file
    - Contains contract.yaml file
    """
{% endif %}
    # Verify module path structure
    module_path = "{{ module_path }}"
    assert "nodes" in module_path, "Module should be in 'nodes' package"

    # Verify version structure (v1_0_0)
    import re
    assert re.search(r'v\d+_\d+_\d+', module_path), \
        "Module path should include version (e.g., v1_0_0)"


{% if node_type == "effect" %}
def test_effect_node_io_operations(contract_data):
{% if test_contract.include_docstrings %}
    """
    Test: Effect node specifies I/O operations in contract.

    Validates:
    - io_operations field exists
    - Each operation has required fields
    - Operation types are valid
    """
{% endif %}
    # Effect nodes should have io_operations
    if "io_operations" in contract_data:
        io_ops = contract_data["io_operations"]
        assert isinstance(io_ops, list), "io_operations should be a list"

        for op in io_ops:
            assert "operation_type" in op, "Each I/O operation should have 'operation_type'"
            assert isinstance(op.get("atomic", True), bool), "atomic should be boolean"
            assert isinstance(op.get("timeout_seconds", 30), int), "timeout_seconds should be integer"
{% endif %}


# ============================================================================
# CONTRACT METADATA TESTS
# ============================================================================

def test_contract_metadata(contract_data):
{% if test_contract.include_docstrings %}
    """
    Test: Contract includes comprehensive metadata.

    Validates:
    - Metadata section exists
    - Domain is specified
    - Tags are present (if applicable)
    - Generated timestamp (for generated nodes)
    """
{% endif %}
    if "metadata" in contract_data:
        metadata = contract_data["metadata"]
        assert isinstance(metadata, dict), "metadata should be a dictionary"

        # Verify common metadata fields
        if "domain" in metadata:
            assert isinstance(metadata["domain"], str), "domain should be a string"
            assert len(metadata["domain"]) > 0, "domain should not be empty"


def test_contract_operations(contract_data):
{% if test_contract.include_docstrings %}
    """
    Test: Contract specifies supported operations.

    Validates:
    - operations field exists
    - operations is a list
    - Each operation is a string
    - At least one operation specified
    """
{% endif %}
    if "operations" in contract_data:
        operations = contract_data["operations"]
        assert isinstance(operations, list), "operations should be a list"
        assert len(operations) > 0, "Should have at least one operation"
        assert all(isinstance(op, str) for op in operations), \
            "All operations should be strings"


def test_contract_performance_requirements(contract_data):
{% if test_contract.include_docstrings %}
    """
    Test: Contract includes performance requirements.

    Validates:
    - performance_requirements section exists
    - Includes execution_time constraints
    - Includes memory_usage constraints (if applicable)
    """
{% endif %}
    if "performance_requirements" in contract_data:
        perf = contract_data["performance_requirements"]
        assert isinstance(perf, dict), "performance_requirements should be a dictionary"

        # Verify execution time constraints
        if "execution_time" in perf:
            exec_time = perf["execution_time"]
            assert "target_ms" in exec_time or "max_ms" in exec_time, \
                "execution_time should specify target_ms or max_ms"


# ============================================================================
# CONTRACT CONSISTENCY TESTS
# ============================================================================

def test_contract_input_output_models_specified(contract_data):
{% if test_contract.include_docstrings %}
    """
    Test: Contract specifies input and output models.

    Validates:
    - input_model is specified
    - output_model is specified
    - Both are non-empty strings
    """
{% endif %}
    assert "input_model" in contract_data
    assert "output_model" in contract_data

    assert isinstance(contract_data["input_model"], str)
    assert isinstance(contract_data["output_model"], str)

    assert len(contract_data["input_model"]) > 0
    assert len(contract_data["output_model"]) > 0


def test_contract_name_matches_service(contract_data):
{% if test_contract.include_docstrings %}
    """
    Test: Contract name is consistent with service/node name.

    Validates:
    - name field is meaningful
    - name relates to node functionality
    - name follows naming conventions
    """
{% endif %}
    name = contract_data["name"]
    assert isinstance(name, str), "Contract name should be a string"
    assert len(name) > 0, "Contract name should not be empty"

    # Verify lowercase with underscores (snake_case)
    import re
    assert re.match(r'^[a-z][a-z0-9_]*$', name), \
        "Contract name should be lowercase with underscores (snake_case)"
