"""Workflow generator for converting Pydantic models to GitHub Actions YAML."""

import logging
from io import StringIO
from pathlib import Path
from typing import Any

import yaml

from ..exceptions import WorkflowGenerationError
from ..models.workflow import WorkflowConfig, WorkflowJob, WorkflowStep

logger = logging.getLogger(__name__)


# WorkflowGenerationError now imported from exceptions module


class YAMLFormatter:
    """Custom YAML formatter for GitHub Actions workflows."""

    @staticmethod
    def format_yaml(data: dict[str, Any]) -> str:
        """Format dictionary as GitHub Actions YAML with proper formatting."""
        stream = StringIO()
        yaml.dump(
            data,
            stream,
            default_flow_style=False,
            sort_keys=False,
            width=120,
            indent=2,
            allow_unicode=True,
        )

        # Post-process to match GitHub Actions conventions
        yaml_content = stream.getvalue()

        # Fix boolean formatting
        yaml_content = yaml_content.replace("'true'", "true")
        yaml_content = yaml_content.replace("'false'", "false")
        yaml_content = yaml_content.replace('"true"', "true")
        yaml_content = yaml_content.replace('"false"', "false")

        # Fix null formatting
        yaml_content = yaml_content.replace("null", "")

        # Ensure proper line spacing around major sections
        yaml_content = yaml_content.replace("\njobs:", "\n\njobs:")
        yaml_content = yaml_content.replace("\nsteps:", "\n  steps:")

        return yaml_content.strip()


class WorkflowGenerator:
    """Generate GitHub Actions workflow YAML from Pydantic models."""

    def __init__(self, formatter: YAMLFormatter | None = None):
        """Initialize workflow generator.

        Args:
            formatter: Custom YAML formatter (uses default if None)
        """
        self.formatter = formatter or YAMLFormatter()

    def generate_yaml(self, workflow: WorkflowConfig) -> str:
        """Generate YAML content from workflow configuration.

        Args:
            workflow: Pydantic workflow configuration

        Returns:
            YAML string representation of the workflow

        Raises:
            WorkflowGenerationError: If generation fails
        """
        try:
            # Convert to YAML-serializable dict
            workflow_dict = workflow.to_yaml_dict()

            # Validate the generated dictionary
            self._validate_workflow_dict(workflow_dict)

            # Format as YAML
            yaml_content = self.formatter.format_yaml(workflow_dict)

            # Add workflow header comment
            header = f"# GitHub Actions Workflow: {workflow.name}\n"
            header += "# Generated by OmniNode Bridge CI System\n\n"

            return header + yaml_content

        except Exception as e:
            logger.error(f"Failed to generate workflow YAML: {e}")
            raise WorkflowGenerationError(f"Workflow generation failed: {e}") from e

    def generate_to_file(
        self, workflow: WorkflowConfig, output_path: str | Path
    ) -> None:
        """Generate workflow YAML and save to file.

        Args:
            workflow: Pydantic workflow configuration
            output_path: Output file path

        Raises:
            WorkflowGenerationError: If generation or file writing fails
        """
        try:
            yaml_content = self.generate_yaml(workflow)

            output_path = Path(output_path)
            output_path.parent.mkdir(parents=True, exist_ok=True)

            with open(output_path, "w", encoding="utf-8") as f:
                f.write(yaml_content)

            logger.info(f"Workflow generated successfully: {output_path}")

        except Exception as e:
            logger.error(f"Failed to generate workflow file: {e}")
            raise WorkflowGenerationError(f"File generation failed: {e}") from e

    def generate_multiple(
        self, workflows: list[WorkflowConfig], output_dir: str | Path
    ) -> list[Path]:
        """Generate multiple workflows to a directory.

        Args:
            workflows: List of workflow configurations
            output_dir: Output directory path

        Returns:
            List of generated file paths

        Raises:
            WorkflowGenerationError: If any generation fails
        """
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)

        generated_files = []
        errors = []

        for workflow in workflows:
            try:
                # Create filename from workflow name
                filename = self._sanitize_filename(workflow.name) + ".yml"
                output_path = output_dir / filename

                self.generate_to_file(workflow, output_path)
                generated_files.append(output_path)

            except Exception as e:
                errors.append(f"Failed to generate {workflow.name}: {e}")

        if errors:
            error_msg = "Some workflows failed to generate:\n" + "\n".join(errors)
            raise WorkflowGenerationError(error_msg)

        return generated_files

    def _validate_workflow_dict(self, workflow_dict: dict[str, Any]) -> None:
        """Validate the workflow dictionary structure.

        Args:
            workflow_dict: Dictionary representation of workflow

        Raises:
            WorkflowGenerationError: If validation fails
        """
        required_fields = ["name", "on", "jobs"]
        missing_fields = [
            field for field in required_fields if field not in workflow_dict
        ]

        if missing_fields:
            raise WorkflowGenerationError(f"Missing required fields: {missing_fields}")

        # Validate jobs
        jobs = workflow_dict.get("jobs", {})
        if not jobs:
            raise WorkflowGenerationError("At least one job must be defined")

        for job_name, job_config in jobs.items():
            self._validate_job_dict(job_name, job_config)

    def _validate_job_dict(self, job_name: str, job_config: dict[str, Any]) -> None:
        """Validate individual job configuration.

        Args:
            job_name: Name of the job
            job_config: Job configuration dictionary

        Raises:
            WorkflowGenerationError: If job validation fails
        """
        required_job_fields = ["runs-on", "steps"]
        missing_fields = [
            field for field in required_job_fields if field not in job_config
        ]

        if missing_fields:
            raise WorkflowGenerationError(
                f"Job '{job_name}' missing required fields: {missing_fields}"
            )

        # Validate steps
        steps = job_config.get("steps", [])
        if not steps:
            raise WorkflowGenerationError(
                f"Job '{job_name}' must have at least one step"
            )

        for i, step in enumerate(steps):
            self._validate_step_dict(job_name, i, step)

    def _validate_step_dict(
        self, job_name: str, step_index: int, step_config: dict[str, Any]
    ) -> None:
        """Validate individual step configuration.

        Args:
            job_name: Name of the containing job
            step_index: Index of the step in the job
            step_config: Step configuration dictionary

        Raises:
            WorkflowGenerationError: If step validation fails
        """
        has_uses = "uses" in step_config and step_config["uses"]
        has_run = "run" in step_config and step_config["run"]

        if not has_uses and not has_run:
            raise WorkflowGenerationError(
                f"Step {step_index} in job '{job_name}' must have either 'uses' or 'run'"
            )

        if has_uses and has_run:
            raise WorkflowGenerationError(
                f"Step {step_index} in job '{job_name}' cannot have both 'uses' and 'run'"
            )

    @staticmethod
    def _sanitize_filename(name: str) -> str:
        """Sanitize workflow name for use as filename.

        Args:
            name: Workflow name

        Returns:
            Sanitized filename (without extension)
        """
        # Replace spaces and special characters with hyphens
        import re

        sanitized = re.sub(r"[^\w\-_]", "-", name.lower())
        sanitized = re.sub(r"-+", "-", sanitized)  # Collapse multiple hyphens
        return sanitized.strip("-")


class WorkflowBuilder:
    """Helper class for building workflows programmatically."""

    def __init__(self, name: str):
        """Initialize workflow builder.

        Args:
            name: Workflow name
        """
        self.name = name
        self.triggers: list[dict[str, Any]] = []
        self.jobs: dict[str, WorkflowJob] = {}
        self.env: dict[str, str] = {}
        self.permissions: dict[str, str] | None = None
        self.concurrency: dict[str, Any] | None = None
        self.defaults: dict[str, Any] | None = None

    def add_trigger(self, event_type: str, **kwargs) -> "WorkflowBuilder":
        """Add a trigger to the workflow.

        Args:
            event_type: GitHub event type
            **kwargs: Additional trigger configuration

        Returns:
            Self for method chaining
        """
        trigger_config = {"type": event_type}
        trigger_config.update(kwargs)
        self.triggers.append(trigger_config)
        return self

    def add_job(self, job_id: str, job: WorkflowJob) -> "WorkflowBuilder":
        """Add a job to the workflow.

        Args:
            job_id: Unique job identifier
            job: Job configuration

        Returns:
            Self for method chaining
        """
        self.jobs[job_id] = job
        return self

    def set_env(self, env_vars: dict[str, str]) -> "WorkflowBuilder":
        """Set global environment variables.

        Args:
            env_vars: Environment variables

        Returns:
            Self for method chaining
        """
        self.env.update(env_vars)
        return self

    def set_permissions(self, permissions: dict[str, str]) -> "WorkflowBuilder":
        """Set workflow permissions.

        Args:
            permissions: Permission configuration

        Returns:
            Self for method chaining
        """
        self.permissions = permissions
        return self

    def build(self) -> WorkflowConfig:
        """Build the workflow configuration.

        Returns:
            Complete workflow configuration

        Raises:
            WorkflowGenerationError: If build fails
        """
        if not self.jobs:
            raise WorkflowGenerationError("Workflow must have at least one job")

        # Convert triggers to workflow 'on' field
        if len(self.triggers) == 1:
            on_config = self.triggers[0]["type"]
        else:
            on_config = [trigger["type"] for trigger in self.triggers]

        config_dict = {"name": self.name, "on": on_config, "jobs": self.jobs}

        if self.env:
            config_dict["env"] = self.env
        if self.permissions:
            config_dict["permissions"] = self.permissions
        if self.concurrency:
            config_dict["concurrency"] = self.concurrency
        if self.defaults:
            config_dict["defaults"] = self.defaults

        return WorkflowConfig(**config_dict)


# Convenience functions for common workflow patterns


def create_simple_ci_workflow(
    name: str,
    python_versions: list[str] | None = None,
    node_versions: list[str] | None = None,
    test_command: str = "pytest",
    lint_command: str = "flake8",
) -> WorkflowConfig:
    """Create a simple CI workflow with testing and linting.

    Args:
        name: Workflow name
        python_versions: Python versions to test (defaults to ['3.11', '3.12'])
        node_versions: Node versions to test (optional)
        test_command: Command to run tests
        lint_command: Command to run linting

    Returns:
        Complete CI workflow configuration
    """
    from ..models.github_actions import CheckoutAction, SetupPythonAction

    if python_versions is None:
        python_versions = ["3.11", "3.12"]

    # Create test job
    steps = [
        WorkflowStep(name="Checkout code", **CheckoutAction().model_dump()),
        WorkflowStep(name="Set up Python", **SetupPythonAction().model_dump()),
        WorkflowStep(
            name="Install dependencies", run="pip install -r requirements.txt"
        ),
        WorkflowStep(name="Run linting", run=lint_command),
        WorkflowStep(name="Run tests", run=test_command),
    ]

    strategy = None
    if len(python_versions) > 1:
        from ..models.workflow import MatrixStrategy

        strategy = MatrixStrategy(matrix={"python-version": python_versions})

    test_job = WorkflowJob.model_validate(
        {
            "name": "Test",
            "runs-on": "ubuntu-latest",
            "strategy": strategy,
            "steps": steps,
        }
    )

    from ..models.workflow import EventType

    return WorkflowConfig(
        name=name, on=[EventType.PUSH, EventType.PULL_REQUEST], jobs={"test": test_job}
    )
