#!/usr/bin/env python3
"""
Data processing effect node with health monitoring.

Demonstrates basic mixin integration with MixinHealthCheck for component health
tracking and Docker HEALTHCHECK compatibility.

Generated by OmniNode Code Generator - Example Implementation
This is a complete, runnable example demonstrating mixin integration.
"""

import asyncio
import logging
from typing import Any

from omnibase_core.models.core.model_container import ModelContainer
from omnibase_core.nodes.node_effect import NodeEffect

# Import health check mixin (from omninode_bridge examples)
try:
    from omninode_bridge.nodes.mixins.health_mixin import HealthCheckMixin, HealthStatus
except ImportError:
    # Fallback for standalone examples
    from typing import Protocol

    class HealthCheckMixin(Protocol):
        """Stub for type checking when mixin not available."""

        def initialize_health_checks(self) -> None: ...
        async def check_health(self) -> Any: ...


logger = logging.getLogger(__name__)


class NodeDataProcessingEffect(NodeEffect, HealthCheckMixin):
    """
    Data processing effect node with health monitoring.

    ONEX v2.0 Compliant Effect Node

    Capabilities:
      Built-in Features (NodeEffect):
        - Circuit breakers with failure threshold
        - Retry policies with exponential backoff
        - Transaction support with rollback
        - Concurrent execution control
        - Performance metrics tracking

      Enhanced Features (Mixins):
        - MixinHealthCheck: Health check implementation with async support

    Example Usage:
        >>> from omnibase_core.models.core.model_container import ModelContainer
        >>> container = ModelContainer()
        >>> node = NodeDataProcessingEffect(container)
        >>> await node.initialize()
        >>>
        >>> # Perform health check
        >>> health_result = await node.check_health()
        >>> print(f"Health: {health_result.overall_status}")
        >>>
        >>> # Process data
        >>> input_data = {"data": "raw_input", "correlation_id": "12345"}
        >>> result = await node.execute(input_data)
        >>> print(f"Processed: {result['processed_data']}")
    """

    def __init__(self, container: ModelContainer):
        """Initialize node with container and mixins."""
        # Initialize base classes (Node + Mixins)
        super().__init__(container)

        # Initialize logger
        self.logger = logging.getLogger(self.__class__.__name__)

        # Initialize mixin components (if available)
        if hasattr(self, "initialize_health_checks"):
            self.initialize_health_checks()

    async def initialize(self) -> None:
        """Initialize node resources and mixins."""
        # Initialize base NodeEffect
        await super().initialize()

        self.logger.info(f"Initializing {self.__class__.__name__}")

        # Setup health checks (if mixin available)
        if hasattr(self, "get_health_checks"):
            health_checks = self.get_health_checks()
            for check_name, check_func in health_checks:
                if hasattr(self, "register_health_check"):
                    self.register_health_check(check_name, check_func)

        self.logger.info(f"{self.__class__.__name__} initialized successfully")

    async def shutdown(self) -> None:
        """Shutdown node and cleanup resources."""
        self.logger.info(f"Shutting down {self.__class__.__name__}")

        # Shutdown base NodeEffect
        await super().shutdown()

    def get_health_checks(self) -> list[tuple[str, Any]]:
        """
        Register health checks for this node.

        Returns:
            List of (check_name, check_function) tuples
        """
        return [
            ("self", self._check_self_health),
            ("database", self._check_database_health),
        ]

    async def _check_self_health(self) -> tuple[HealthStatus, str, dict[str, Any]]:
        """
        Check node's own health status.

        Returns:
            Tuple of (status, message, details)
        """
        try:
            # Check node has required attributes
            node_id = getattr(self, "node_id", None)
            container = getattr(self, "container", None)

            if not node_id:
                return (
                    HealthStatus.UNHEALTHY,
                    "Node ID not set",
                    {"missing": "node_id"},
                )

            if not container:
                return (
                    HealthStatus.DEGRADED,
                    "Container not available",
                    {"missing": "container"},
                )

            # Node is operational
            return (
                HealthStatus.HEALTHY,
                "Node is healthy",
                {
                    "node_id": str(node_id),
                    "has_container": container is not None,
                },
            )
        except Exception as e:
            self.logger.error(f"Health check failed: {e}")
            return (
                HealthStatus.UNHEALTHY,
                f"Health check failed: {e!s}",
                {"error": str(e)},
            )

    async def _check_database_health(self) -> tuple[HealthStatus, str, dict[str, Any]]:
        """
        Check database connection health.

        Returns:
            Tuple of (status, message, details)
        """
        try:
            # Get database client from container (if available)
            db_client = None
            if hasattr(self.container, "db_client"):
                db_client = self.container.db_client

            if not db_client:
                return (
                    HealthStatus.DEGRADED,
                    "Database client not configured",
                    {"configured": False},
                )

            # Test database connection with simple query
            if hasattr(db_client, "execute"):
                await asyncio.wait_for(db_client.execute("SELECT 1"), timeout=3.0)

            return (
                HealthStatus.HEALTHY,
                "Database connection healthy",
                {"configured": True, "connected": True},
            )

        except asyncio.TimeoutError:
            return (
                HealthStatus.UNHEALTHY,
                "Database query timed out",
                {"timeout_seconds": 3.0},
            )

        except Exception as e:
            self.logger.warning(f"Database health check failed: {e}")
            return (
                HealthStatus.UNHEALTHY,
                f"Database connection failed: {e!s}",
                {"error": str(e)},
            )

    async def execute_effect(self, input_data: dict[str, Any]) -> dict[str, Any]:
        """
        Execute the data processing effect.

        This is the main business logic method called by NodeEffect.execute().

        Args:
            input_data: Input data dictionary with 'data' field

        Returns:
            Output data dictionary with processed results

        Example:
            >>> result = await node.execute_effect({
            ...     "data": "raw_input",
            ...     "correlation_id": "12345"
            ... })
            >>> print(result)
            {
                "processed_data": "PROCESSED: raw_input",
                "processing_time_ms": 1.23,
                "status": "success"
            }
        """
        import time

        start_time = time.time()

        try:
            # Extract input
            raw_data = input_data.get("data", "")
            correlation_id = input_data.get("correlation_id", "unknown")

            self.logger.info(
                "Processing data",
                extra={"correlation_id": correlation_id, "data_length": len(raw_data)},
            )

            # TODO: Implement actual data processing logic
            # This is a simple example that uppercases the input
            processed_data = f"PROCESSED: {raw_data.upper()}"

            # Simulate some processing time
            await asyncio.sleep(0.01)

            processing_time_ms = (time.time() - start_time) * 1000

            return {
                "processed_data": processed_data,
                "processing_time_ms": processing_time_ms,
                "status": "success",
            }

        except Exception as e:
            self.logger.error(f"Processing failed: {e}")
            processing_time_ms = (time.time() - start_time) * 1000

            return {
                "processed_data": "",
                "processing_time_ms": processing_time_ms,
                "status": "failed",
                "error": str(e),
            }


# Example usage and testing
async def main():
    """Example usage of the data processing node."""
    print("=" * 60)
    print("Basic Effect with Health Check - Example")
    print("=" * 60)
    print()

    # Create container and node
    container = ModelContainer()
    node = NodeDataProcessingEffect(container)

    try:
        # Initialize node
        print("1. Initializing node...")
        await node.initialize()
        print("   ✓ Node initialized")
        print()

        # Check health
        print("2. Checking health...")
        if hasattr(node, "check_health"):
            health_result = await node.check_health()
            health_dict = health_result.to_dict()
            print(f"   Overall Status: {health_dict['overall_status']}")
            print(f"   Components: {len(health_dict['components'])}")
            for comp in health_dict["components"]:
                status_icon = "✓" if comp["status"] == "healthy" else "✗"
                print(f"     {status_icon} {comp['name']}: {comp['status']}")
        else:
            print("   ⚠ Health check mixin not available")
        print()

        # Process data
        print("3. Processing data...")
        input_data = {"data": "hello world", "correlation_id": "example-001"}
        result = await node.execute_effect(input_data)
        print(f"   Input: {input_data['data']}")
        print(f"   Output: {result['processed_data']}")
        print(f"   Processing Time: {result['processing_time_ms']:.2f}ms")
        print(f"   Status: {result['status']}")
        print()

        # Shutdown
        print("4. Shutting down...")
        await node.shutdown()
        print("   ✓ Node shutdown complete")

    except Exception as e:
        print(f"   ✗ Error: {e}")
        import traceback

        traceback.print_exc()

    print()
    print("=" * 60)
    print("Example complete!")
    print("=" * 60)


if __name__ == "__main__":
    # Run example
    asyncio.run(main())
